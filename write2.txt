STREAM
ORGANIZATION OF THIS DOCUMENT
TYPES OF STREAMS
STREAMS PROMISES API
STREAM.PIPELINE(SOURCE[, ...TRANSFORMS], DESTINATION[, OPTIONS])
STREAM.PIPELINE(STREAMS[, OPTIONS])
STREAM.FINISHED(STREAM[, OPTIONS])
OBJECT MODE
BUFFERING
API FOR STREAM CONSUMERS
WRITABLE STREAMS
CLASS: STREAM.WRITABLE
EVENT: 'CLOSE'
EVENT: 'DRAIN'
EVENT: 'ERROR'
EVENT: 'FINISH'
EVENT: 'PIPE'
EVENT: 'UNPIPE'
WRITABLE.CORK()
WRITABLE.DESTROY([ERROR])
WRITABLE.CLOSED
WRITABLE.DESTROYED
WRITABLE.END([CHUNK[, ENCODING]][, CALLBACK])
WRITABLE.SETDEFAULTENCODING(ENCODING)
WRITABLE.UNCORK()
WRITABLE.WRITABLE
WRITABLE.WRITABLEABORTED
WRITABLE.WRITABLEENDED
WRITABLE.WRITABLECORKED
WRITABLE.ERRORED
WRITABLE.WRITABLEFINISHED
WRITABLE.WRITABLEHIGHWATERMARK
WRITABLE.WRITABLELENGTH
WRITABLE.WRITABLENEEDDRAIN
WRITABLE.WRITABLEOBJECTMODE
WRITABLE.WRITE(CHUNK[, ENCODING][, CALLBACK])
READABLE STREAMS
TWO READING MODES
THREE STATES
CHOOSE ONE API STYLE
CLASS: STREAM.READABLE
EVENT: 'CLOSE'
EVENT: 'DATA'
EVENT: 'END'
EVENT: 'ERROR'
EVENT: 'PAUSE'
EVENT: 'READABLE'
EVENT: 'RESUME'
READABLE.DESTROY([ERROR])
READABLE.CLOSED
READABLE.DESTROYED
READABLE.ISPAUSED()
READABLE.PAUSE()
READABLE.PIPE(DESTINATION[, OPTIONS])
READABLE.READ([SIZE])
READABLE.READABLE
READABLE.READABLEABORTED
READABLE.READABLEDIDREAD
READABLE.READABLEENCODING
READABLE.READABLEENDED
READABLE.ERRORED
READABLE.READABLEFLOWING
READABLE.READABLEHIGHWATERMARK
READABLE.READABLELENGTH
READABLE.READABLEOBJECTMODE
READABLE.RESUME()
READABLE.SETENCODING(ENCODING)
READABLE.UNPIPE([DESTINATION])
READABLE.UNSHIFT(CHUNK[, ENCODING])
READABLE.WRAP(STREAM)
READABLE[SYMBOL.ASYNCITERATOR]()
READABLE.COMPOSE(STREAM[, OPTIONS])
READABLE.ITERATOR([OPTIONS])
READABLE.MAP(FN[, OPTIONS])
READABLE.FILTER(FN[, OPTIONS])
READABLE.FOREACH(FN[, OPTIONS])
READABLE.TOARRAY([OPTIONS])
READABLE.SOME(FN[, OPTIONS])
READABLE.FIND(FN[, OPTIONS])
READABLE.EVERY(FN[, OPTIONS])
READABLE.FLATMAP(FN[, OPTIONS])
READABLE.DROP(LIMIT[, OPTIONS])
READABLE.TAKE(LIMIT[, OPTIONS])
READABLE.ASINDEXEDPAIRS([OPTIONS])
READABLE.REDUCE(FN[, INITIAL[, OPTIONS]])
DUPLEX AND TRANSFORM STREAMS
CLASS: STREAM.DUPLEX
DUPLEX.ALLOWHALFOPEN
CLASS: STREAM.TRANSFORM
TRANSFORM.DESTROY([ERROR])
STREAM.FINISHED(STREAM[, OPTIONS], CALLBACK)
STREAM.PIPELINE(SOURCE[, ...TRANSFORMS], DESTINATION, CALLBACK)
STREAM.PIPELINE(STREAMS, CALLBACK)
STREAM.COMPOSE(...STREAMS)
STREAM.READABLE.FROM(ITERABLE[, OPTIONS])
STREAM.READABLE.FROMWEB(READABLESTREAM[, OPTIONS])
STREAM.READABLE.ISDISTURBED(STREAM)
STREAM.ISERRORED(STREAM)
STREAM.ISREADABLE(STREAM)
STREAM.READABLE.TOWEB(STREAMREADABLE[, OPTIONS])
STREAM.WRITABLE.FROMWEB(WRITABLESTREAM[, OPTIONS])
STREAM.WRITABLE.TOWEB(STREAMWRITABLE)
STREAM.DUPLEX.FROM(SRC)
STREAM.DUPLEX.FROMWEB(PAIR[, OPTIONS])
STREAM.DUPLEX.TOWEB(STREAMDUPLEX)
STREAM.ADDABORTSIGNAL(SIGNAL, STREAM)
STREAM.GETDEFAULTHIGHWATERMARK(OBJECTMODE)
STREAM.SETDEFAULTHIGHWATERMARK(OBJECTMODE, VALUE)
API FOR STREAM IMPLEMENTERS
SIMPLIFIED CONSTRUCTION
IMPLEMENTING A WRITABLE STREAM
NEW STREAM.WRITABLE([OPTIONS])
WRITABLE._CONSTRUCT(CALLBACK)
WRITABLE._WRITE(CHUNK, ENCODING, CALLBACK)
WRITABLE._WRITEV(CHUNKS, CALLBACK)
WRITABLE._DESTROY(ERR, CALLBACK)
WRITABLE._FINAL(CALLBACK)
ERRORS WHILE WRITING
AN EXAMPLE WRITABLE STREAM
DECODING BUFFERS IN A WRITABLE STREAM
IMPLEMENTING A READABLE STREAM
NEW STREAM.READABLE([OPTIONS])
READABLE._CONSTRUCT(CALLBACK)
READABLE._READ(SIZE)
READABLE._DESTROY(ERR, CALLBACK)
READABLE.PUSH(CHUNK[, ENCODING])
ERRORS WHILE READING
AN EXAMPLE COUNTING STREAM
IMPLEMENTING A DUPLEX STREAM
NEW STREAM.DUPLEX(OPTIONS)
AN EXAMPLE DUPLEX STREAM
OBJECT MODE DUPLEX STREAMS
IMPLEMENTING A TRANSFORM STREAM
NEW STREAM.TRANSFORM([OPTIONS])
EVENT: 'END'
EVENT: 'FINISH'
TRANSFORM._FLUSH(CALLBACK)
TRANSFORM._TRANSFORM(CHUNK, ENCODING, CALLBACK)
CLASS: STREAM.PASSTHROUGH
ADDITIONAL NOTES
STREAMS COMPATIBILITY WITH ASYNC GENERATORS AND ASYNC ITERATORS
CONSUMING READABLE STREAMS WITH ASYNC ITERATORS
CREATING READABLE STREAMS WITH ASYNC GENERATORS
PIPING TO WRITABLE STREAMS FROM ASYNC ITERATORS
COMPATIBILITY WITH OLDER NODE.JS VERSIONS
READABLE.READ(0)
READABLE.PUSH('')
HIGHWATERMARK DISCREPANCY AFTER CALLING READABLE.SETENCODING()
STREAM[SRC]#
STABILITY: 2 - STABLE
SOURCE CODE: LIB/STREAM.JS

A STREAM IS AN ABSTRACT INTERFACE FOR WORKING WITH STREAMING DATA IN NODE.JS. THE NODE:STREAM MODULE PROVIDES AN API FOR IMPLEMENTING THE STREAM INTERFACE.

THERE ARE MANY STREAM OBJECTS PROVIDED BY NODE.JS. FOR INSTANCE, A REQUEST TO AN HTTP SERVER AND PROCESS.STDOUT ARE BOTH STREAM INSTANCES.

STREAMS CAN BE READABLE, WRITABLE, OR BOTH. ALL STREAMS ARE INSTANCES OF EVENTEMITTER.

TO ACCESS THE NODE:STREAM MODULE:

CONST STREAM = REQUIRE('NODE:STREAM'); COPY
THE NODE:STREAM MODULE IS USEFUL FOR CREATING NEW TYPES OF STREAM INSTANCES. IT IS USUALLY NOT NECESSARY TO USE THE NODE:STREAM MODULE TO CONSUME STREAMS.

ORGANIZATION OF THIS DOCUMENT#
THIS DOCUMENT CONTAINS TWO PRIMARY SECTIONS AND A THIRD SECTION FOR NOTES. THE FIRST SECTION EXPLAINS HOW TO USE EXISTING STREAMS WITHIN AN APPLICATION. THE SECOND SECTION EXPLAINS HOW TO CREATE NEW TYPES OF STREAMS.

TYPES OF STREAMS#
THERE ARE FOUR FUNDAMENTAL STREAM TYPES WITHIN NODE.JS:

WRITABLE: STREAMS TO WHICH DATA CAN BE WRITTEN (FOR EXAMPLE, FS.CREATEWRITESTREAM()).
READABLE: STREAMS FROM WHICH DATA CAN BE READ (FOR EXAMPLE, FS.CREATEREADSTREAM()).
DUPLEX: STREAMS THAT ARE BOTH READABLE AND WRITABLE (FOR EXAMPLE, NET.SOCKET).
TRANSFORM: DUPLEX STREAMS THAT CAN MODIFY OR TRANSFORM THE DATA AS IT IS WRITTEN AND READ (FOR EXAMPLE, ZLIB.CREATEDEFLATE()).
ADDITIONALLY, THIS MODULE INCLUDES THE UTILITY FUNCTIONS STREAM.PIPELINE(), STREAM.FINISHED(), STREAM.READABLE.FROM() AND STREAM.ADDABORTSIGNAL().

STREAMS PROMISES API#
ADDED IN: V15.0.0
THE STREAM/PROMISES API PROVIDES AN ALTERNATIVE SET OF ASYNCHRONOUS UTILITY FUNCTIONS FOR STREAMS THAT RETURN PROMISE OBJECTS RATHER THAN USING CALLBACKS. THE API IS ACCESSIBLE VIA REQUIRE('NODE:STREAM/PROMISES') OR REQUIRE('NODE:STREAM').PROMISES.

STREAM.PIPELINE(SOURCE[, ...TRANSFORMS], DESTINATION[, OPTIONS])#
STREAM.PIPELINE(STREAMS[, OPTIONS])#
ADDED IN: V15.0.0
STREAMS <STREAM[]> | <ITERABLE[]> | <ASYNCITERABLE[]> | <FUNCTION[]>
SOURCE <STREAM> | <ITERABLE> | <ASYNCITERABLE> | <FUNCTION>
RETURNS: <PROMISE> | <ASYNCITERABLE>
...TRANSFORMS <STREAM> | <FUNCTION>
SOURCE <ASYNCITERABLE>
RETURNS: <PROMISE> | <ASYNCITERABLE>
DESTINATION <STREAM> | <FUNCTION>
SOURCE <ASYNCITERABLE>
RETURNS: <PROMISE> | <ASYNCITERABLE>
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL>
END <BOOLEAN>
RETURNS: <PROMISE> FULFILLS WHEN THE PIPELINE IS COMPLETE.
IMPORT { PIPELINE } FROM 'NODE:STREAM/PROMISES';
IMPORT { CREATEREADSTREAM, CREATEWRITESTREAM } FROM 'NODE:FS';
IMPORT { CREATEGZIP } FROM 'NODE:ZLIB';

AWAIT PIPELINE(
  CREATEREADSTREAM('ARCHIVE.TAR'),
  CREATEGZIP(),
  CREATEWRITESTREAM('ARCHIVE.TAR.GZ'),
);
CONSOLE.LOG('PIPELINE SUCCEEDED.');COPY
TO USE AN ABORTSIGNAL, PASS IT INSIDE AN OPTIONS OBJECT, AS THE LAST ARGUMENT. WHEN THE SIGNAL IS ABORTED, DESTROY WILL BE CALLED ON THE UNDERLYING PIPELINE, WITH AN ABORTERROR.

IMPORT { PIPELINE } FROM 'NODE:STREAM/PROMISES';
IMPORT { CREATEREADSTREAM, CREATEWRITESTREAM } FROM 'NODE:FS';
IMPORT { CREATEGZIP } FROM 'NODE:ZLIB';

CONST AC = NEW ABORTCONTROLLER();
CONST { SIGNAL } = AC;
SETIMMEDIATE(() => AC.ABORT());
TRY {
  AWAIT PIPELINE(
    CREATEREADSTREAM('ARCHIVE.TAR'),
    CREATEGZIP(),
    CREATEWRITESTREAM('ARCHIVE.TAR.GZ'),
    { SIGNAL },
  );
} CATCH (ERR) {
  CONSOLE.ERROR(ERR); // ABORTERROR
}COPY
THE PIPELINE API ALSO SUPPORTS ASYNC GENERATORS:

IMPORT { PIPELINE } FROM 'NODE:STREAM/PROMISES';
IMPORT { CREATEREADSTREAM, CREATEWRITESTREAM } FROM 'NODE:FS';

AWAIT PIPELINE(
  CREATEREADSTREAM('LOWERCASE.TXT'),
  ASYNC FUNCTION* (SOURCE, { SIGNAL }) {
    SOURCE.SETENCODING('UTF8');  // WORK WITH STRINGS RATHER THAN `BUFFER`S.
    FOR AWAIT (CONST CHUNK OF SOURCE) {
      YIELD AWAIT PROCESSCHUNK(CHUNK, { SIGNAL });
    }
  },
  CREATEWRITESTREAM('UPPERCASE.TXT'),
);
CONSOLE.LOG('PIPELINE SUCCEEDED.');COPY
REMEMBER TO HANDLE THE SIGNAL ARGUMENT PASSED INTO THE ASYNC GENERATOR. ESPECIALLY IN THE CASE WHERE THE ASYNC GENERATOR IS THE SOURCE FOR THE PIPELINE (I.E. FIRST ARGUMENT) OR THE PIPELINE WILL NEVER COMPLETE.

IMPORT { PIPELINE } FROM 'NODE:STREAM/PROMISES';
IMPORT FS FROM 'NODE:FS';
AWAIT PIPELINE(
  ASYNC FUNCTION* ({ SIGNAL }) {
    AWAIT SOMELONGRUNNINGFN({ SIGNAL });
    YIELD 'ASD';
  },
  FS.CREATEWRITESTREAM('UPPERCASE.TXT'),
);
CONSOLE.LOG('PIPELINE SUCCEEDED.');COPY
THE PIPELINE API PROVIDES CALLBACK VERSION:

STREAM.FINISHED(STREAM[, OPTIONS])#
ADDED IN: V15.0.0
STREAM <STREAM>
OPTIONS <OBJECT>
ERROR <BOOLEAN> | <UNDEFINED>
READABLE <BOOLEAN> | <UNDEFINED>
WRITABLE <BOOLEAN> | <UNDEFINED>
SIGNAL: <ABORTSIGNAL> | <UNDEFINED>
RETURNS: <PROMISE> FULFILLS WHEN THE STREAM IS NO LONGER READABLE OR WRITABLE.
IMPORT { FINISHED } FROM 'NODE:STREAM/PROMISES';
IMPORT { CREATEREADSTREAM } FROM 'NODE:FS';

CONST RS = CREATEREADSTREAM('ARCHIVE.TAR');

ASYNC FUNCTION RUN() {
  AWAIT FINISHED(RS);
  CONSOLE.LOG('STREAM IS DONE READING.');
}

RUN().CATCH(CONSOLE.ERROR);
RS.RESUME(); // DRAIN THE STREAM.COPY
THE FINISHED API PROVIDES CALLBACK VERSION:

OBJECT MODE#
ALL STREAMS CREATED BY NODE.JS APIS OPERATE EXCLUSIVELY ON STRINGS AND BUFFER (OR UINT8ARRAY) OBJECTS. IT IS POSSIBLE, HOWEVER, FOR STREAM IMPLEMENTATIONS TO WORK WITH OTHER TYPES OF JAVASCRIPT VALUES (WITH THE EXCEPTION OF NULL, WHICH SERVES A SPECIAL PURPOSE WITHIN STREAMS). SUCH STREAMS ARE CONSIDERED TO OPERATE IN "OBJECT MODE".

STREAM INSTANCES ARE SWITCHED INTO OBJECT MODE USING THE OBJECTMODE OPTION WHEN THE STREAM IS CREATED. ATTEMPTING TO SWITCH AN EXISTING STREAM INTO OBJECT MODE IS NOT SAFE.

BUFFERING#
BOTH WRITABLE AND READABLE STREAMS WILL STORE DATA IN AN INTERNAL BUFFER.

THE AMOUNT OF DATA POTENTIALLY BUFFERED DEPENDS ON THE HIGHWATERMARK OPTION PASSED INTO THE STREAM'S CONSTRUCTOR. FOR NORMAL STREAMS, THE HIGHWATERMARK OPTION SPECIFIES A TOTAL NUMBER OF BYTES. FOR STREAMS OPERATING IN OBJECT MODE, THE HIGHWATERMARK SPECIFIES A TOTAL NUMBER OF OBJECTS.

DATA IS BUFFERED IN READABLE STREAMS WHEN THE IMPLEMENTATION CALLS STREAM.PUSH(CHUNK). IF THE CONSUMER OF THE STREAM DOES NOT CALL STREAM.READ(), THE DATA WILL SIT IN THE INTERNAL QUEUE UNTIL IT IS CONSUMED.

ONCE THE TOTAL SIZE OF THE INTERNAL READ BUFFER REACHES THE THRESHOLD SPECIFIED BY HIGHWATERMARK, THE STREAM WILL TEMPORARILY STOP READING DATA FROM THE UNDERLYING RESOURCE UNTIL THE DATA CURRENTLY BUFFERED CAN BE CONSUMED (THAT IS, THE STREAM WILL STOP CALLING THE INTERNAL READABLE._READ() METHOD THAT IS USED TO FILL THE READ BUFFER).

DATA IS BUFFERED IN WRITABLE STREAMS WHEN THE WRITABLE.WRITE(CHUNK) METHOD IS CALLED REPEATEDLY. WHILE THE TOTAL SIZE OF THE INTERNAL WRITE BUFFER IS BELOW THE THRESHOLD SET BY HIGHWATERMARK, CALLS TO WRITABLE.WRITE() WILL RETURN TRUE. ONCE THE SIZE OF THE INTERNAL BUFFER REACHES OR EXCEEDS THE HIGHWATERMARK, FALSE WILL BE RETURNED.

A KEY GOAL OF THE STREAM API, PARTICULARLY THE STREAM.PIPE() METHOD, IS TO LIMIT THE BUFFERING OF DATA TO ACCEPTABLE LEVELS SUCH THAT SOURCES AND DESTINATIONS OF DIFFERING SPEEDS WILL NOT OVERWHELM THE AVAILABLE MEMORY.

THE HIGHWATERMARK OPTION IS A THRESHOLD, NOT A LIMIT: IT DICTATES THE AMOUNT OF DATA THAT A STREAM BUFFERS BEFORE IT STOPS ASKING FOR MORE DATA. IT DOES NOT ENFORCE A STRICT MEMORY LIMITATION IN GENERAL. SPECIFIC STREAM IMPLEMENTATIONS MAY CHOOSE TO ENFORCE STRICTER LIMITS BUT DOING SO IS OPTIONAL.

BECAUSE DUPLEX AND TRANSFORM STREAMS ARE BOTH READABLE AND WRITABLE, EACH MAINTAINS TWO SEPARATE INTERNAL BUFFERS USED FOR READING AND WRITING, ALLOWING EACH SIDE TO OPERATE INDEPENDENTLY OF THE OTHER WHILE MAINTAINING AN APPROPRIATE AND EFFICIENT FLOW OF DATA. FOR EXAMPLE, NET.SOCKET INSTANCES ARE DUPLEX STREAMS WHOSE READABLE SIDE ALLOWS CONSUMPTION OF DATA RECEIVED FROM THE SOCKET AND WHOSE WRITABLE SIDE ALLOWS WRITING DATA TO THE SOCKET. BECAUSE DATA MAY BE WRITTEN TO THE SOCKET AT A FASTER OR SLOWER RATE THAN DATA IS RECEIVED, EACH SIDE SHOULD OPERATE (AND BUFFER) INDEPENDENTLY OF THE OTHER.

THE MECHANICS OF THE INTERNAL BUFFERING ARE AN INTERNAL IMPLEMENTATION DETAIL AND MAY BE CHANGED AT ANY TIME. HOWEVER, FOR CERTAIN ADVANCED IMPLEMENTATIONS, THE INTERNAL BUFFERS CAN BE RETRIEVED USING WRITABLE.WRITABLEBUFFER OR READABLE.READABLEBUFFER. USE OF THESE UNDOCUMENTED PROPERTIES IS DISCOURAGED.

API FOR STREAM CONSUMERS#
ALMOST ALL NODE.JS APPLICATIONS, NO MATTER HOW SIMPLE, USE STREAMS IN SOME MANNER. THE FOLLOWING IS AN EXAMPLE OF USING STREAMS IN A NODE.JS APPLICATION THAT IMPLEMENTS AN HTTP SERVER:

CONST HTTP = REQUIRE('NODE:HTTP');

CONST SERVER = HTTP.CREATESERVER((REQ, RES) => {
  // `REQ` IS AN HTTP.INCOMINGMESSAGE, WHICH IS A READABLE STREAM.
  // `RES` IS AN HTTP.SERVERRESPONSE, WHICH IS A WRITABLE STREAM.

  LET BODY = '';
  // GET THE DATA AS UTF8 STRINGS.
  // IF AN ENCODING IS NOT SET, BUFFER OBJECTS WILL BE RECEIVED.
  REQ.SETENCODING('UTF8');

  // READABLE STREAMS EMIT 'DATA' EVENTS ONCE A LISTENER IS ADDED.
  REQ.ON('DATA', (CHUNK) => {
    BODY += CHUNK;
  });

  // THE 'END' EVENT INDICATES THAT THE ENTIRE BODY HAS BEEN RECEIVED.
  REQ.ON('END', () => {
    TRY {
      CONST DATA = JSON.PARSE(BODY);
      // WRITE BACK SOMETHING INTERESTING TO THE USER:
      RES.WRITE(TYPEOF DATA);
      RES.END();
    } CATCH (ER) {
      // UH OH! BAD JSON!
      RES.STATUSCODE = 400;
      RETURN RES.END(`ERROR: ${ER.MESSAGE}`);
    }
  });
});

SERVER.LISTEN(1337);

// $ CURL LOCALHOST:1337 -D "{}"
// OBJECT
// $ CURL LOCALHOST:1337 -D "\"FOO\""
// STRING
// $ CURL LOCALHOST:1337 -D "NOT JSON"
// ERROR: UNEXPECTED TOKEN 'O', "NOT JSON" IS NOT VALID JSON COPY
WRITABLE STREAMS (SUCH AS RES IN THE EXAMPLE) EXPOSE METHODS SUCH AS WRITE() AND END() THAT ARE USED TO WRITE DATA ONTO THE STREAM.

READABLE STREAMS USE THE EVENTEMITTER API FOR NOTIFYING APPLICATION CODE WHEN DATA IS AVAILABLE TO BE READ OFF THE STREAM. THAT AVAILABLE DATA CAN BE READ FROM THE STREAM IN MULTIPLE WAYS.

BOTH WRITABLE AND READABLE STREAMS USE THE EVENTEMITTER API IN VARIOUS WAYS TO COMMUNICATE THE CURRENT STATE OF THE STREAM.

DUPLEX AND TRANSFORM STREAMS ARE BOTH WRITABLE AND READABLE.

APPLICATIONS THAT ARE EITHER WRITING DATA TO OR CONSUMING DATA FROM A STREAM ARE NOT REQUIRED TO IMPLEMENT THE STREAM INTERFACES DIRECTLY AND WILL GENERALLY HAVE NO REASON TO CALL REQUIRE('NODE:STREAM').

DEVELOPERS WISHING TO IMPLEMENT NEW TYPES OF STREAMS SHOULD REFER TO THE SECTION API FOR STREAM IMPLEMENTERS.

WRITABLE STREAMS#
WRITABLE STREAMS ARE AN ABSTRACTION FOR A DESTINATION TO WHICH DATA IS WRITTEN.

EXAMPLES OF WRITABLE STREAMS INCLUDE:

HTTP REQUESTS, ON THE CLIENT
HTTP RESPONSES, ON THE SERVER
FS WRITE STREAMS
ZLIB STREAMS
CRYPTO STREAMS
TCP SOCKETS
CHILD PROCESS STDIN
PROCESS.STDOUT, PROCESS.STDERR
SOME OF THESE EXAMPLES ARE ACTUALLY DUPLEX STREAMS THAT IMPLEMENT THE WRITABLE INTERFACE.

ALL WRITABLE STREAMS IMPLEMENT THE INTERFACE DEFINED BY THE STREAM.WRITABLE CLASS.

WHILE SPECIFIC INSTANCES OF WRITABLE STREAMS MAY DIFFER IN VARIOUS WAYS, ALL WRITABLE STREAMS FOLLOW THE SAME FUNDAMENTAL USAGE PATTERN AS ILLUSTRATED IN THE EXAMPLE BELOW:

CONST MYSTREAM = GETWRITABLESTREAMSOMEHOW();
MYSTREAM.WRITE('SOME DATA');
MYSTREAM.WRITE('SOME MORE DATA');
MYSTREAM.END('DONE WRITING DATA'); COPY
CLASS: STREAM.WRITABLE#
ADDED IN: V0.9.4
EVENT: 'CLOSE'#
HISTORY
VERSION	CHANGES
V10.0.0	
ADD EMITCLOSE OPTION TO SPECIFY IF 'CLOSE' IS EMITTED ON DESTROY.

V0.9.4	
ADDED IN: V0.9.4

THE 'CLOSE' EVENT IS EMITTED WHEN THE STREAM AND ANY OF ITS UNDERLYING RESOURCES (A FILE DESCRIPTOR, FOR EXAMPLE) HAVE BEEN CLOSED. THE EVENT INDICATES THAT NO MORE EVENTS WILL BE EMITTED, AND NO FURTHER COMPUTATION WILL OCCUR.

A WRITABLE STREAM WILL ALWAYS EMIT THE 'CLOSE' EVENT IF IT IS CREATED WITH THE EMITCLOSE OPTION.

EVENT: 'DRAIN'#
ADDED IN: V0.9.4
IF A CALL TO STREAM.WRITE(CHUNK) RETURNS FALSE, THE 'DRAIN' EVENT WILL BE EMITTED WHEN IT IS APPROPRIATE TO RESUME WRITING DATA TO THE STREAM.

// WRITE THE DATA TO THE SUPPLIED WRITABLE STREAM ONE MILLION TIMES.
// BE ATTENTIVE TO BACK-PRESSURE.
FUNCTION WRITEONEMILLIONTIMES(WRITER, DATA, ENCODING, CALLBACK) {
  LET I = 1000000;
  WRITE();
  FUNCTION WRITE() {
    LET OK = TRUE;
    DO {
      I--;
      IF (I === 0) {
        // LAST TIME!
        WRITER.WRITE(DATA, ENCODING, CALLBACK);
      } ELSE {
        // SEE IF WE SHOULD CONTINUE, OR WAIT.
        // DON'T PASS THE CALLBACK, BECAUSE WE'RE NOT DONE YET.
        OK = WRITER.WRITE(DATA, ENCODING);
      }
    } WHILE (I > 0 && OK);
    IF (I > 0) {
      // HAD TO STOP EARLY!
      // WRITE SOME MORE ONCE IT DRAINS.
      WRITER.ONCE('DRAIN', WRITE);
    }
  }
} COPY
EVENT: 'ERROR'#
ADDED IN: V0.9.4
<ERROR>
THE 'ERROR' EVENT IS EMITTED IF AN ERROR OCCURRED WHILE WRITING OR PIPING DATA. THE LISTENER CALLBACK IS PASSED A SINGLE ERROR ARGUMENT WHEN CALLED.

THE STREAM IS CLOSED WHEN THE 'ERROR' EVENT IS EMITTED UNLESS THE AUTODESTROY OPTION WAS SET TO FALSE WHEN CREATING THE STREAM.

AFTER 'ERROR', NO FURTHER EVENTS OTHER THAN 'CLOSE' SHOULD BE EMITTED (INCLUDING 'ERROR' EVENTS).

EVENT: 'FINISH'#
ADDED IN: V0.9.4
THE 'FINISH' EVENT IS EMITTED AFTER THE STREAM.END() METHOD HAS BEEN CALLED, AND ALL DATA HAS BEEN FLUSHED TO THE UNDERLYING SYSTEM.

CONST WRITER = GETWRITABLESTREAMSOMEHOW();
FOR (LET I = 0; I < 100; I++) {
  WRITER.WRITE(`HELLO, #${I}!\N`);
}
WRITER.ON('FINISH', () => {
  CONSOLE.LOG('ALL WRITES ARE NOW COMPLETE.');
});
WRITER.END('THIS IS THE END\N'); COPY
EVENT: 'PIPE'#
ADDED IN: V0.9.4
SRC <STREAM.READABLE> SOURCE STREAM THAT IS PIPING TO THIS WRITABLE
THE 'PIPE' EVENT IS EMITTED WHEN THE STREAM.PIPE() METHOD IS CALLED ON A READABLE STREAM, ADDING THIS WRITABLE TO ITS SET OF DESTINATIONS.

CONST WRITER = GETWRITABLESTREAMSOMEHOW();
CONST READER = GETREADABLESTREAMSOMEHOW();
WRITER.ON('PIPE', (SRC) => {
  CONSOLE.LOG('SOMETHING IS PIPING INTO THE WRITER.');
  ASSERT.EQUAL(SRC, READER);
});
READER.PIPE(WRITER); COPY
EVENT: 'UNPIPE'#
ADDED IN: V0.9.4
SRC <STREAM.READABLE> THE SOURCE STREAM THAT UNPIPED THIS WRITABLE
THE 'UNPIPE' EVENT IS EMITTED WHEN THE STREAM.UNPIPE() METHOD IS CALLED ON A READABLE STREAM, REMOVING THIS WRITABLE FROM ITS SET OF DESTINATIONS.

THIS IS ALSO EMITTED IN CASE THIS WRITABLE STREAM EMITS AN ERROR WHEN A READABLE STREAM PIPES INTO IT.

CONST WRITER = GETWRITABLESTREAMSOMEHOW();
CONST READER = GETREADABLESTREAMSOMEHOW();
WRITER.ON('UNPIPE', (SRC) => {
  CONSOLE.LOG('SOMETHING HAS STOPPED PIPING INTO THE WRITER.');
  ASSERT.EQUAL(SRC, READER);
});
READER.PIPE(WRITER);
READER.UNPIPE(WRITER); COPY
WRITABLE.CORK()#
ADDED IN: V0.11.2
THE WRITABLE.CORK() METHOD FORCES ALL WRITTEN DATA TO BE BUFFERED IN MEMORY. THE BUFFERED DATA WILL BE FLUSHED WHEN EITHER THE STREAM.UNCORK() OR STREAM.END() METHODS ARE CALLED.

THE PRIMARY INTENT OF WRITABLE.CORK() IS TO ACCOMMODATE A SITUATION IN WHICH SEVERAL SMALL CHUNKS ARE WRITTEN TO THE STREAM IN RAPID SUCCESSION. INSTEAD OF IMMEDIATELY FORWARDING THEM TO THE UNDERLYING DESTINATION, WRITABLE.CORK() BUFFERS ALL THE CHUNKS UNTIL WRITABLE.UNCORK() IS CALLED, WHICH WILL PASS THEM ALL TO WRITABLE._WRITEV(), IF PRESENT. THIS PREVENTS A HEAD-OF-LINE BLOCKING SITUATION WHERE DATA IS BEING BUFFERED WHILE WAITING FOR THE FIRST SMALL CHUNK TO BE PROCESSED. HOWEVER, USE OF WRITABLE.CORK() WITHOUT IMPLEMENTING WRITABLE._WRITEV() MAY HAVE AN ADVERSE EFFECT ON THROUGHPUT.

SEE ALSO: WRITABLE.UNCORK(), WRITABLE._WRITEV().

WRITABLE.DESTROY([ERROR])#
HISTORY
ERROR <ERROR> OPTIONAL, AN ERROR TO EMIT WITH 'ERROR' EVENT.
RETURNS: <THIS>
DESTROY THE STREAM. OPTIONALLY EMIT AN 'ERROR' EVENT, AND EMIT A 'CLOSE' EVENT (UNLESS EMITCLOSE IS SET TO FALSE). AFTER THIS CALL, THE WRITABLE STREAM HAS ENDED AND SUBSEQUENT CALLS TO WRITE() OR END() WILL RESULT IN AN ERR_STREAM_DESTROYED ERROR. THIS IS A DESTRUCTIVE AND IMMEDIATE WAY TO DESTROY A STREAM. PREVIOUS CALLS TO WRITE() MAY NOT HAVE DRAINED, AND MAY TRIGGER AN ERR_STREAM_DESTROYED ERROR. USE END() INSTEAD OF DESTROY IF DATA SHOULD FLUSH BEFORE CLOSE, OR WAIT FOR THE 'DRAIN' EVENT BEFORE DESTROYING THE STREAM.

CONST { WRITABLE } = REQUIRE('NODE:STREAM');

CONST MYSTREAM = NEW WRITABLE();

CONST FOOERR = NEW ERROR('FOO ERROR');
MYSTREAM.DESTROY(FOOERR);
MYSTREAM.ON('ERROR', (FOOERR) => CONSOLE.ERROR(FOOERR.MESSAGE)); // FOO ERROR COPY
CONST { WRITABLE } = REQUIRE('NODE:STREAM');

CONST MYSTREAM = NEW WRITABLE();

MYSTREAM.DESTROY();
MYSTREAM.ON('ERROR', FUNCTION WONTHAPPEN() {}); COPY
CONST { WRITABLE } = REQUIRE('NODE:STREAM');

CONST MYSTREAM = NEW WRITABLE();
MYSTREAM.DESTROY();

MYSTREAM.WRITE('FOO', (ERROR) => CONSOLE.ERROR(ERROR.CODE));
// ERR_STREAM_DESTROYED COPY
ONCE DESTROY() HAS BEEN CALLED ANY FURTHER CALLS WILL BE A NO-OP AND NO FURTHER ERRORS EXCEPT FROM _DESTROY() MAY BE EMITTED AS 'ERROR'.

IMPLEMENTORS SHOULD NOT OVERRIDE THIS METHOD, BUT INSTEAD IMPLEMENT WRITABLE._DESTROY().

WRITABLE.CLOSED#
ADDED IN: V18.0.0
<BOOLEAN>
IS TRUE AFTER 'CLOSE' HAS BEEN EMITTED.

WRITABLE.DESTROYED#
ADDED IN: V8.0.0
<BOOLEAN>
IS TRUE AFTER WRITABLE.DESTROY() HAS BEEN CALLED.

CONST { WRITABLE } = REQUIRE('NODE:STREAM');

CONST MYSTREAM = NEW WRITABLE();

CONSOLE.LOG(MYSTREAM.DESTROYED); // FALSE
MYSTREAM.DESTROY();
CONSOLE.LOG(MYSTREAM.DESTROYED); // TRUE COPY
WRITABLE.END([CHUNK[, ENCODING]][, CALLBACK])#
HISTORY
CHUNK <STRING> | <BUFFER> | <UINT8ARRAY> | <ANY> OPTIONAL DATA TO WRITE. FOR STREAMS NOT OPERATING IN OBJECT MODE, CHUNK MUST BE A STRING, BUFFER OR UINT8ARRAY. FOR OBJECT MODE STREAMS, CHUNK MAY BE ANY JAVASCRIPT VALUE OTHER THAN NULL.
ENCODING <STRING> THE ENCODING IF CHUNK IS A STRING
CALLBACK <FUNCTION> CALLBACK FOR WHEN THE STREAM IS FINISHED.
RETURNS: <THIS>
CALLING THE WRITABLE.END() METHOD SIGNALS THAT NO MORE DATA WILL BE WRITTEN TO THE WRITABLE. THE OPTIONAL CHUNK AND ENCODING ARGUMENTS ALLOW ONE FINAL ADDITIONAL CHUNK OF DATA TO BE WRITTEN IMMEDIATELY BEFORE CLOSING THE STREAM.

CALLING THE STREAM.WRITE() METHOD AFTER CALLING STREAM.END() WILL RAISE AN ERROR.

// WRITE 'HELLO, ' AND THEN END WITH 'WORLD!'.
CONST FS = REQUIRE('NODE:FS');
CONST FILE = FS.CREATEWRITESTREAM('EXAMPLE.TXT');
FILE.WRITE('HELLO, ');
FILE.END('WORLD!');
// WRITING MORE NOW IS NOT ALLOWED! COPY
WRITABLE.SETDEFAULTENCODING(ENCODING)#
HISTORY
ENCODING <STRING> THE NEW DEFAULT ENCODING
RETURNS: <THIS>
THE WRITABLE.SETDEFAULTENCODING() METHOD SETS THE DEFAULT ENCODING FOR A WRITABLE STREAM.

WRITABLE.UNCORK()#
ADDED IN: V0.11.2
THE WRITABLE.UNCORK() METHOD FLUSHES ALL DATA BUFFERED SINCE STREAM.CORK() WAS CALLED.

WHEN USING WRITABLE.CORK() AND WRITABLE.UNCORK() TO MANAGE THE BUFFERING OF WRITES TO A STREAM, DEFER CALLS TO WRITABLE.UNCORK() USING PROCESS.NEXTTICK(). DOING SO ALLOWS BATCHING OF ALL WRITABLE.WRITE() CALLS THAT OCCUR WITHIN A GIVEN NODE.JS EVENT LOOP PHASE.

STREAM.CORK();
STREAM.WRITE('SOME ');
STREAM.WRITE('DATA ');
PROCESS.NEXTTICK(() => STREAM.UNCORK()); COPY
IF THE WRITABLE.CORK() METHOD IS CALLED MULTIPLE TIMES ON A STREAM, THE SAME NUMBER OF CALLS TO WRITABLE.UNCORK() MUST BE CALLED TO FLUSH THE BUFFERED DATA.

STREAM.CORK();
STREAM.WRITE('SOME ');
STREAM.CORK();
STREAM.WRITE('DATA ');
PROCESS.NEXTTICK(() => {
  STREAM.UNCORK();
  // THE DATA WILL NOT BE FLUSHED UNTIL UNCORK() IS CALLED A SECOND TIME.
  STREAM.UNCORK();
}); COPY
SEE ALSO: WRITABLE.CORK().

WRITABLE.WRITABLE#
ADDED IN: V11.4.0
<BOOLEAN>
IS TRUE IF IT IS SAFE TO CALL WRITABLE.WRITE(), WHICH MEANS THE STREAM HAS NOT BEEN DESTROYED, ERRORED, OR ENDED.

WRITABLE.WRITABLEABORTED#
ADDED IN: V18.0.0, V16.17.0
STABILITY: 1 - EXPERIMENTAL
<BOOLEAN>
RETURNS WHETHER THE STREAM WAS DESTROYED OR ERRORED BEFORE EMITTING 'FINISH'.

WRITABLE.WRITABLEENDED#
ADDED IN: V12.9.0
<BOOLEAN>
IS TRUE AFTER WRITABLE.END() HAS BEEN CALLED. THIS PROPERTY DOES NOT INDICATE WHETHER THE DATA HAS BEEN FLUSHED, FOR THIS USE WRITABLE.WRITABLEFINISHED INSTEAD.

WRITABLE.WRITABLECORKED#
ADDED IN: V13.2.0, V12.16.0
<INTEGER>
NUMBER OF TIMES WRITABLE.UNCORK() NEEDS TO BE CALLED IN ORDER TO FULLY UNCORK THE STREAM.

WRITABLE.ERRORED#
ADDED IN: V18.0.0
<ERROR>
RETURNS ERROR IF THE STREAM HAS BEEN DESTROYED WITH AN ERROR.

WRITABLE.WRITABLEFINISHED#
ADDED IN: V12.6.0
<BOOLEAN>
IS SET TO TRUE IMMEDIATELY BEFORE THE 'FINISH' EVENT IS EMITTED.

WRITABLE.WRITABLEHIGHWATERMARK#
ADDED IN: V9.3.0
<NUMBER>
RETURN THE VALUE OF HIGHWATERMARK PASSED WHEN CREATING THIS WRITABLE.

WRITABLE.WRITABLELENGTH#
ADDED IN: V9.4.0
<NUMBER>
THIS PROPERTY CONTAINS THE NUMBER OF BYTES (OR OBJECTS) IN THE QUEUE READY TO BE WRITTEN. THE VALUE PROVIDES INTROSPECTION DATA REGARDING THE STATUS OF THE HIGHWATERMARK.

WRITABLE.WRITABLENEEDDRAIN#
ADDED IN: V15.2.0, V14.17.0
<BOOLEAN>
IS TRUE IF THE STREAM'S BUFFER HAS BEEN FULL AND STREAM WILL EMIT 'DRAIN'.

WRITABLE.WRITABLEOBJECTMODE#
ADDED IN: V12.3.0
<BOOLEAN>
GETTER FOR THE PROPERTY OBJECTMODE OF A GIVEN WRITABLE STREAM.

WRITABLE.WRITE(CHUNK[, ENCODING][, CALLBACK])#
HISTORY
CHUNK <STRING> | <BUFFER> | <UINT8ARRAY> | <ANY> OPTIONAL DATA TO WRITE. FOR STREAMS NOT OPERATING IN OBJECT MODE, CHUNK MUST BE A STRING, BUFFER OR UINT8ARRAY. FOR OBJECT MODE STREAMS, CHUNK MAY BE ANY JAVASCRIPT VALUE OTHER THAN NULL.
ENCODING <STRING> | <NULL> THE ENCODING, IF CHUNK IS A STRING. DEFAULT: 'UTF8'
CALLBACK <FUNCTION> CALLBACK FOR WHEN THIS CHUNK OF DATA IS FLUSHED.
RETURNS: <BOOLEAN> FALSE IF THE STREAM WISHES FOR THE CALLING CODE TO WAIT FOR THE 'DRAIN' EVENT TO BE EMITTED BEFORE CONTINUING TO WRITE ADDITIONAL DATA; OTHERWISE TRUE.
THE WRITABLE.WRITE() METHOD WRITES SOME DATA TO THE STREAM, AND CALLS THE SUPPLIED CALLBACK ONCE THE DATA HAS BEEN FULLY HANDLED. IF AN ERROR OCCURS, THE CALLBACK WILL BE CALLED WITH THE ERROR AS ITS FIRST ARGUMENT. THE CALLBACK IS CALLED ASYNCHRONOUSLY AND BEFORE 'ERROR' IS EMITTED.

THE RETURN VALUE IS TRUE IF THE INTERNAL BUFFER IS LESS THAN THE HIGHWATERMARK CONFIGURED WHEN THE STREAM WAS CREATED AFTER ADMITTING CHUNK. IF FALSE IS RETURNED, FURTHER ATTEMPTS TO WRITE DATA TO THE STREAM SHOULD STOP UNTIL THE 'DRAIN' EVENT IS EMITTED.

WHILE A STREAM IS NOT DRAINING, CALLS TO WRITE() WILL BUFFER CHUNK, AND RETURN FALSE. ONCE ALL CURRENTLY BUFFERED CHUNKS ARE DRAINED (ACCEPTED FOR DELIVERY BY THE OPERATING SYSTEM), THE 'DRAIN' EVENT WILL BE EMITTED. ONCE WRITE() RETURNS FALSE, DO NOT WRITE MORE CHUNKS UNTIL THE 'DRAIN' EVENT IS EMITTED. WHILE CALLING WRITE() ON A STREAM THAT IS NOT DRAINING IS ALLOWED, NODE.JS WILL BUFFER ALL WRITTEN CHUNKS UNTIL MAXIMUM MEMORY USAGE OCCURS, AT WHICH POINT IT WILL ABORT UNCONDITIONALLY. EVEN BEFORE IT ABORTS, HIGH MEMORY USAGE WILL CAUSE POOR GARBAGE COLLECTOR PERFORMANCE AND HIGH RSS (WHICH IS NOT TYPICALLY RELEASED BACK TO THE SYSTEM, EVEN AFTER THE MEMORY IS NO LONGER REQUIRED). SINCE TCP SOCKETS MAY NEVER DRAIN IF THE REMOTE PEER DOES NOT READ THE DATA, WRITING A SOCKET THAT IS NOT DRAINING MAY LEAD TO A REMOTELY EXPLOITABLE VULNERABILITY.

WRITING DATA WHILE THE STREAM IS NOT DRAINING IS PARTICULARLY PROBLEMATIC FOR A TRANSFORM, BECAUSE THE TRANSFORM STREAMS ARE PAUSED BY DEFAULT UNTIL THEY ARE PIPED OR A 'DATA' OR 'READABLE' EVENT HANDLER IS ADDED.

IF THE DATA TO BE WRITTEN CAN BE GENERATED OR FETCHED ON DEMAND, IT IS RECOMMENDED TO ENCAPSULATE THE LOGIC INTO A READABLE AND USE STREAM.PIPE(). HOWEVER, IF CALLING WRITE() IS PREFERRED, IT IS POSSIBLE TO RESPECT BACKPRESSURE AND AVOID MEMORY ISSUES USING THE 'DRAIN' EVENT:

FUNCTION WRITE(DATA, CB) {
  IF (!STREAM.WRITE(DATA)) {
    STREAM.ONCE('DRAIN', CB);
  } ELSE {
    PROCESS.NEXTTICK(CB);
  }
}

// WAIT FOR CB TO BE CALLED BEFORE DOING ANY OTHER WRITE.
WRITE('HELLO', () => {
  CONSOLE.LOG('WRITE COMPLETED, DO MORE WRITES NOW.');
}); COPY
A WRITABLE STREAM IN OBJECT MODE WILL ALWAYS IGNORE THE ENCODING ARGUMENT.

READABLE STREAMS#
READABLE STREAMS ARE AN ABSTRACTION FOR A SOURCE FROM WHICH DATA IS CONSUMED.

EXAMPLES OF READABLE STREAMS INCLUDE:

HTTP RESPONSES, ON THE CLIENT
HTTP REQUESTS, ON THE SERVER
FS READ STREAMS
ZLIB STREAMS
CRYPTO STREAMS
TCP SOCKETS
CHILD PROCESS STDOUT AND STDERR
PROCESS.STDIN
ALL READABLE STREAMS IMPLEMENT THE INTERFACE DEFINED BY THE STREAM.READABLE CLASS.

TWO READING MODES#
READABLE STREAMS EFFECTIVELY OPERATE IN ONE OF TWO MODES: FLOWING AND PAUSED. THESE MODES ARE SEPARATE FROM OBJECT MODE. A READABLE STREAM CAN BE IN OBJECT MODE OR NOT, REGARDLESS OF WHETHER IT IS IN FLOWING MODE OR PAUSED MODE.

IN FLOWING MODE, DATA IS READ FROM THE UNDERLYING SYSTEM AUTOMATICALLY AND PROVIDED TO AN APPLICATION AS QUICKLY AS POSSIBLE USING EVENTS VIA THE EVENTEMITTER INTERFACE.

IN PAUSED MODE, THE STREAM.READ() METHOD MUST BE CALLED EXPLICITLY TO READ CHUNKS OF DATA FROM THE STREAM.

ALL READABLE STREAMS BEGIN IN PAUSED MODE BUT CAN BE SWITCHED TO FLOWING MODE IN ONE OF THE FOLLOWING WAYS:

ADDING A 'DATA' EVENT HANDLER.
CALLING THE STREAM.RESUME() METHOD.
CALLING THE STREAM.PIPE() METHOD TO SEND THE DATA TO A WRITABLE.
THE READABLE CAN SWITCH BACK TO PAUSED MODE USING ONE OF THE FOLLOWING:

IF THERE ARE NO PIPE DESTINATIONS, BY CALLING THE STREAM.PAUSE() METHOD.
IF THERE ARE PIPE DESTINATIONS, BY REMOVING ALL PIPE DESTINATIONS. MULTIPLE PIPE DESTINATIONS MAY BE REMOVED BY CALLING THE STREAM.UNPIPE() METHOD.
THE IMPORTANT CONCEPT TO REMEMBER IS THAT A READABLE WILL NOT GENERATE DATA UNTIL A MECHANISM FOR EITHER CONSUMING OR IGNORING THAT DATA IS PROVIDED. IF THE CONSUMING MECHANISM IS DISABLED OR TAKEN AWAY, THE READABLE WILL ATTEMPT TO STOP GENERATING THE DATA.

FOR BACKWARD COMPATIBILITY REASONS, REMOVING 'DATA' EVENT HANDLERS WILL NOT AUTOMATICALLY PAUSE THE STREAM. ALSO, IF THERE ARE PIPED DESTINATIONS, THEN CALLING STREAM.PAUSE() WILL NOT GUARANTEE THAT THE STREAM WILL REMAIN PAUSED ONCE THOSE DESTINATIONS DRAIN AND ASK FOR MORE DATA.

IF A READABLE IS SWITCHED INTO FLOWING MODE AND THERE ARE NO CONSUMERS AVAILABLE TO HANDLE THE DATA, THAT DATA WILL BE LOST. THIS CAN OCCUR, FOR INSTANCE, WHEN THE READABLE.RESUME() METHOD IS CALLED WITHOUT A LISTENER ATTACHED TO THE 'DATA' EVENT, OR WHEN A 'DATA' EVENT HANDLER IS REMOVED FROM THE STREAM.

ADDING A 'READABLE' EVENT HANDLER AUTOMATICALLY MAKES THE STREAM STOP FLOWING, AND THE DATA HAS TO BE CONSUMED VIA READABLE.READ(). IF THE 'READABLE' EVENT HANDLER IS REMOVED, THEN THE STREAM WILL START FLOWING AGAIN IF THERE IS A 'DATA' EVENT HANDLER.

THREE STATES#
THE "TWO MODES" OF OPERATION FOR A READABLE STREAM ARE A SIMPLIFIED ABSTRACTION FOR THE MORE COMPLICATED INTERNAL STATE MANAGEMENT THAT IS HAPPENING WITHIN THE READABLE STREAM IMPLEMENTATION.

SPECIFICALLY, AT ANY GIVEN POINT IN TIME, EVERY READABLE IS IN ONE OF THREE POSSIBLE STATES:

READABLE.READABLEFLOWING === NULL
READABLE.READABLEFLOWING === FALSE
READABLE.READABLEFLOWING === TRUE
WHEN READABLE.READABLEFLOWING IS NULL, NO MECHANISM FOR CONSUMING THE STREAM'S DATA IS PROVIDED. THEREFORE, THE STREAM WILL NOT GENERATE DATA. WHILE IN THIS STATE, ATTACHING A LISTENER FOR THE 'DATA' EVENT, CALLING THE READABLE.PIPE() METHOD, OR CALLING THE READABLE.RESUME() METHOD WILL SWITCH READABLE.READABLEFLOWING TO TRUE, CAUSING THE READABLE TO BEGIN ACTIVELY EMITTING EVENTS AS DATA IS GENERATED.

CALLING READABLE.PAUSE(), READABLE.UNPIPE(), OR RECEIVING BACKPRESSURE WILL CAUSE THE READABLE.READABLEFLOWING TO BE SET AS FALSE, TEMPORARILY HALTING THE FLOWING OF EVENTS BUT NOT HALTING THE GENERATION OF DATA. WHILE IN THIS STATE, ATTACHING A LISTENER FOR THE 'DATA' EVENT WILL NOT SWITCH READABLE.READABLEFLOWING TO TRUE.

CONST { PASSTHROUGH, WRITABLE } = REQUIRE('NODE:STREAM');
CONST PASS = NEW PASSTHROUGH();
CONST WRITABLE = NEW WRITABLE();

PASS.PIPE(WRITABLE);
PASS.UNPIPE(WRITABLE);
// READABLEFLOWING IS NOW FALSE.

PASS.ON('DATA', (CHUNK) => { CONSOLE.LOG(CHUNK.TOSTRING()); });
// READABLEFLOWING IS STILL FALSE.
PASS.WRITE('OK');  // WILL NOT EMIT 'DATA'.
PASS.RESUME();     // MUST BE CALLED TO MAKE STREAM EMIT 'DATA'.
// READABLEFLOWING IS NOW TRUE. COPY
WHILE READABLE.READABLEFLOWING IS FALSE, DATA MAY BE ACCUMULATING WITHIN THE STREAM'S INTERNAL BUFFER.

CHOOSE ONE API STYLE#
THE READABLE STREAM API EVOLVED ACROSS MULTIPLE NODE.JS VERSIONS AND PROVIDES MULTIPLE METHODS OF CONSUMING STREAM DATA. IN GENERAL, DEVELOPERS SHOULD CHOOSE ONE OF THE METHODS OF CONSUMING DATA AND SHOULD NEVER USE MULTIPLE METHODS TO CONSUME DATA FROM A SINGLE STREAM. SPECIFICALLY, USING A COMBINATION OF ON('DATA'), ON('READABLE'), PIPE(), OR ASYNC ITERATORS COULD LEAD TO UNINTUITIVE BEHAVIOR.

CLASS: STREAM.READABLE#
ADDED IN: V0.9.4
EVENT: 'CLOSE'#
HISTORY
THE 'CLOSE' EVENT IS EMITTED WHEN THE STREAM AND ANY OF ITS UNDERLYING RESOURCES (A FILE DESCRIPTOR, FOR EXAMPLE) HAVE BEEN CLOSED. THE EVENT INDICATES THAT NO MORE EVENTS WILL BE EMITTED, AND NO FURTHER COMPUTATION WILL OCCUR.

A READABLE STREAM WILL ALWAYS EMIT THE 'CLOSE' EVENT IF IT IS CREATED WITH THE EMITCLOSE OPTION.

EVENT: 'DATA'#
ADDED IN: V0.9.4
CHUNK <BUFFER> | <STRING> | <ANY> THE CHUNK OF DATA. FOR STREAMS THAT ARE NOT OPERATING IN OBJECT MODE, THE CHUNK WILL BE EITHER A STRING OR BUFFER. FOR STREAMS THAT ARE IN OBJECT MODE, THE CHUNK CAN BE ANY JAVASCRIPT VALUE OTHER THAN NULL.
THE 'DATA' EVENT IS EMITTED WHENEVER THE STREAM IS RELINQUISHING OWNERSHIP OF A CHUNK OF DATA TO A CONSUMER. THIS MAY OCCUR WHENEVER THE STREAM IS SWITCHED IN FLOWING MODE BY CALLING READABLE.PIPE(), READABLE.RESUME(), OR BY ATTACHING A LISTENER CALLBACK TO THE 'DATA' EVENT. THE 'DATA' EVENT WILL ALSO BE EMITTED WHENEVER THE READABLE.READ() METHOD IS CALLED AND A CHUNK OF DATA IS AVAILABLE TO BE RETURNED.

ATTACHING A 'DATA' EVENT LISTENER TO A STREAM THAT HAS NOT BEEN EXPLICITLY PAUSED WILL SWITCH THE STREAM INTO FLOWING MODE. DATA WILL THEN BE PASSED AS SOON AS IT IS AVAILABLE.

THE LISTENER CALLBACK WILL BE PASSED THE CHUNK OF DATA AS A STRING IF A DEFAULT ENCODING HAS BEEN SPECIFIED FOR THE STREAM USING THE READABLE.SETENCODING() METHOD; OTHERWISE THE DATA WILL BE PASSED AS A BUFFER.

CONST READABLE = GETREADABLESTREAMSOMEHOW();
READABLE.ON('DATA', (CHUNK) => {
  CONSOLE.LOG(`RECEIVED ${CHUNK.LENGTH} BYTES OF DATA.`);
}); COPY
EVENT: 'END'#
ADDED IN: V0.9.4
THE 'END' EVENT IS EMITTED WHEN THERE IS NO MORE DATA TO BE CONSUMED FROM THE STREAM.

THE 'END' EVENT WILL NOT BE EMITTED UNLESS THE DATA IS COMPLETELY CONSUMED. THIS CAN BE ACCOMPLISHED BY SWITCHING THE STREAM INTO FLOWING MODE, OR BY CALLING STREAM.READ() REPEATEDLY UNTIL ALL DATA HAS BEEN CONSUMED.

CONST READABLE = GETREADABLESTREAMSOMEHOW();
READABLE.ON('DATA', (CHUNK) => {
  CONSOLE.LOG(`RECEIVED ${CHUNK.LENGTH} BYTES OF DATA.`);
});
READABLE.ON('END', () => {
  CONSOLE.LOG('THERE WILL BE NO MORE DATA.');
}); COPY
EVENT: 'ERROR'#
ADDED IN: V0.9.4
<ERROR>
THE 'ERROR' EVENT MAY BE EMITTED BY A READABLE IMPLEMENTATION AT ANY TIME. TYPICALLY, THIS MAY OCCUR IF THE UNDERLYING STREAM IS UNABLE TO GENERATE DATA DUE TO AN UNDERLYING INTERNAL FAILURE, OR WHEN A STREAM IMPLEMENTATION ATTEMPTS TO PUSH AN INVALID CHUNK OF DATA.

THE LISTENER CALLBACK WILL BE PASSED A SINGLE ERROR OBJECT.

EVENT: 'PAUSE'#
ADDED IN: V0.9.4
THE 'PAUSE' EVENT IS EMITTED WHEN STREAM.PAUSE() IS CALLED AND READABLEFLOWING IS NOT FALSE.

EVENT: 'READABLE'#
HISTORY
THE 'READABLE' EVENT IS EMITTED WHEN THERE IS DATA AVAILABLE TO BE READ FROM THE STREAM OR WHEN THE END OF THE STREAM HAS BEEN REACHED. EFFECTIVELY, THE 'READABLE' EVENT INDICATES THAT THE STREAM HAS NEW INFORMATION. IF DATA IS AVAILABLE, STREAM.READ() WILL RETURN THAT DATA.

CONST READABLE = GETREADABLESTREAMSOMEHOW();
READABLE.ON('READABLE', FUNCTION() {
  // THERE IS SOME DATA TO READ NOW.
  LET DATA;

  WHILE ((DATA = THIS.READ()) !== NULL) {
    CONSOLE.LOG(DATA);
  }
}); COPY
IF THE END OF THE STREAM HAS BEEN REACHED, CALLING STREAM.READ() WILL RETURN NULL AND TRIGGER THE 'END' EVENT. THIS IS ALSO TRUE IF THERE NEVER WAS ANY DATA TO BE READ. FOR INSTANCE, IN THE FOLLOWING EXAMPLE, FOO.TXT IS AN EMPTY FILE:

CONST FS = REQUIRE('NODE:FS');
CONST RR = FS.CREATEREADSTREAM('FOO.TXT');
RR.ON('READABLE', () => {
  CONSOLE.LOG(`READABLE: ${RR.READ()}`);
});
RR.ON('END', () => {
  CONSOLE.LOG('END');
}); COPY
THE OUTPUT OF RUNNING THIS SCRIPT IS:

$ NODE TEST.JS
READABLE: NULL
END COPY
IN SOME CASES, ATTACHING A LISTENER FOR THE 'READABLE' EVENT WILL CAUSE SOME AMOUNT OF DATA TO BE READ INTO AN INTERNAL BUFFER.

IN GENERAL, THE READABLE.PIPE() AND 'DATA' EVENT MECHANISMS ARE EASIER TO UNDERSTAND THAN THE 'READABLE' EVENT. HOWEVER, HANDLING 'READABLE' MIGHT RESULT IN INCREASED THROUGHPUT.

IF BOTH 'READABLE' AND 'DATA' ARE USED AT THE SAME TIME, 'READABLE' TAKES PRECEDENCE IN CONTROLLING THE FLOW, I.E. 'DATA' WILL BE EMITTED ONLY WHEN STREAM.READ() IS CALLED. THE READABLEFLOWING PROPERTY WOULD BECOME FALSE. IF THERE ARE 'DATA' LISTENERS WHEN 'READABLE' IS REMOVED, THE STREAM WILL START FLOWING, I.E. 'DATA' EVENTS WILL BE EMITTED WITHOUT CALLING .RESUME().

EVENT: 'RESUME'#
ADDED IN: V0.9.4
THE 'RESUME' EVENT IS EMITTED WHEN STREAM.RESUME() IS CALLED AND READABLEFLOWING IS NOT TRUE.

READABLE.DESTROY([ERROR])#
HISTORY
ERROR <ERROR> ERROR WHICH WILL BE PASSED AS PAYLOAD IN 'ERROR' EVENT
RETURNS: <THIS>
DESTROY THE STREAM. OPTIONALLY EMIT AN 'ERROR' EVENT, AND EMIT A 'CLOSE' EVENT (UNLESS EMITCLOSE IS SET TO FALSE). AFTER THIS CALL, THE READABLE STREAM WILL RELEASE ANY INTERNAL RESOURCES AND SUBSEQUENT CALLS TO PUSH() WILL BE IGNORED.

ONCE DESTROY() HAS BEEN CALLED ANY FURTHER CALLS WILL BE A NO-OP AND NO FURTHER ERRORS EXCEPT FROM _DESTROY() MAY BE EMITTED AS 'ERROR'.

IMPLEMENTORS SHOULD NOT OVERRIDE THIS METHOD, BUT INSTEAD IMPLEMENT READABLE._DESTROY().

READABLE.CLOSED#
ADDED IN: V18.0.0
<BOOLEAN>
IS TRUE AFTER 'CLOSE' HAS BEEN EMITTED.

READABLE.DESTROYED#
ADDED IN: V8.0.0
<BOOLEAN>
IS TRUE AFTER READABLE.DESTROY() HAS BEEN CALLED.

READABLE.ISPAUSED()#
ADDED IN: V0.11.14
RETURNS: <BOOLEAN>
THE READABLE.ISPAUSED() METHOD RETURNS THE CURRENT OPERATING STATE OF THE READABLE. THIS IS USED PRIMARILY BY THE MECHANISM THAT UNDERLIES THE READABLE.PIPE() METHOD. IN MOST TYPICAL CASES, THERE WILL BE NO REASON TO USE THIS METHOD DIRECTLY.

CONST READABLE = NEW STREAM.READABLE();

READABLE.ISPAUSED(); // === FALSE
READABLE.PAUSE();
READABLE.ISPAUSED(); // === TRUE
READABLE.RESUME();
READABLE.ISPAUSED(); // === FALSE COPY
READABLE.PAUSE()#
ADDED IN: V0.9.4
RETURNS: <THIS>
THE READABLE.PAUSE() METHOD WILL CAUSE A STREAM IN FLOWING MODE TO STOP EMITTING 'DATA' EVENTS, SWITCHING OUT OF FLOWING MODE. ANY DATA THAT BECOMES AVAILABLE WILL REMAIN IN THE INTERNAL BUFFER.

CONST READABLE = GETREADABLESTREAMSOMEHOW();
READABLE.ON('DATA', (CHUNK) => {
  CONSOLE.LOG(`RECEIVED ${CHUNK.LENGTH} BYTES OF DATA.`);
  READABLE.PAUSE();
  CONSOLE.LOG('THERE WILL BE NO ADDITIONAL DATA FOR 1 SECOND.');
  SETTIMEOUT(() => {
    CONSOLE.LOG('NOW DATA WILL START FLOWING AGAIN.');
    READABLE.RESUME();
  }, 1000);
}); COPY
THE READABLE.PAUSE() METHOD HAS NO EFFECT IF THERE IS A 'READABLE' EVENT LISTENER.

READABLE.PIPE(DESTINATION[, OPTIONS])#
ADDED IN: V0.9.4
DESTINATION <STREAM.WRITABLE> THE DESTINATION FOR WRITING DATA
OPTIONS <OBJECT> PIPE OPTIONS
END <BOOLEAN> END THE WRITER WHEN THE READER ENDS. DEFAULT: TRUE.
RETURNS: <STREAM.WRITABLE> THE DESTINATION, ALLOWING FOR A CHAIN OF PIPES IF IT IS A DUPLEX OR A TRANSFORM STREAM
THE READABLE.PIPE() METHOD ATTACHES A WRITABLE STREAM TO THE READABLE, CAUSING IT TO SWITCH AUTOMATICALLY INTO FLOWING MODE AND PUSH ALL OF ITS DATA TO THE ATTACHED WRITABLE. THE FLOW OF DATA WILL BE AUTOMATICALLY MANAGED SO THAT THE DESTINATION WRITABLE STREAM IS NOT OVERWHELMED BY A FASTER READABLE STREAM.

THE FOLLOWING EXAMPLE PIPES ALL OF THE DATA FROM THE READABLE INTO A FILE NAMED FILE.TXT:

CONST FS = REQUIRE('NODE:FS');
CONST READABLE = GETREADABLESTREAMSOMEHOW();
CONST WRITABLE = FS.CREATEWRITESTREAM('FILE.TXT');
// ALL THE DATA FROM READABLE GOES INTO 'FILE.TXT'.
READABLE.PIPE(WRITABLE); COPY
IT IS POSSIBLE TO ATTACH MULTIPLE WRITABLE STREAMS TO A SINGLE READABLE STREAM.

THE READABLE.PIPE() METHOD RETURNS A REFERENCE TO THE DESTINATION STREAM MAKING IT POSSIBLE TO SET UP CHAINS OF PIPED STREAMS:

CONST FS = REQUIRE('NODE:FS');
CONST ZLIB = REQUIRE('NODE:ZLIB');
CONST R = FS.CREATEREADSTREAM('FILE.TXT');
CONST Z = ZLIB.CREATEGZIP();
CONST W = FS.CREATEWRITESTREAM('FILE.TXT.GZ');
R.PIPE(Z).PIPE(W); COPY
BY DEFAULT, STREAM.END() IS CALLED ON THE DESTINATION WRITABLE STREAM WHEN THE SOURCE READABLE STREAM EMITS 'END', SO THAT THE DESTINATION IS NO LONGER WRITABLE. TO DISABLE THIS DEFAULT BEHAVIOR, THE END OPTION CAN BE PASSED AS FALSE, CAUSING THE DESTINATION STREAM TO REMAIN OPEN:

READER.PIPE(WRITER, { END: FALSE });
READER.ON('END', () => {
  WRITER.END('GOODBYE\N');
}); COPY
ONE IMPORTANT CAVEAT IS THAT IF THE READABLE STREAM EMITS AN ERROR DURING PROCESSING, THE WRITABLE DESTINATION IS NOT CLOSED AUTOMATICALLY. IF AN ERROR OCCURS, IT WILL BE NECESSARY TO MANUALLY CLOSE EACH STREAM IN ORDER TO PREVENT MEMORY LEAKS.

THE PROCESS.STDERR AND PROCESS.STDOUT WRITABLE STREAMS ARE NEVER CLOSED UNTIL THE NODE.JS PROCESS EXITS, REGARDLESS OF THE SPECIFIED OPTIONS.

READABLE.READ([SIZE])#
ADDED IN: V0.9.4
SIZE <NUMBER> OPTIONAL ARGUMENT TO SPECIFY HOW MUCH DATA TO READ.
RETURNS: <STRING> | <BUFFER> | <NULL> | <ANY>
THE READABLE.READ() METHOD READS DATA OUT OF THE INTERNAL BUFFER AND RETURNS IT. IF NO DATA IS AVAILABLE TO BE READ, NULL IS RETURNED. BY DEFAULT, THE DATA IS RETURNED AS A BUFFER OBJECT UNLESS AN ENCODING HAS BEEN SPECIFIED USING THE READABLE.SETENCODING() METHOD OR THE STREAM IS OPERATING IN OBJECT MODE.

THE OPTIONAL SIZE ARGUMENT SPECIFIES A SPECIFIC NUMBER OF BYTES TO READ. IF SIZE BYTES ARE NOT AVAILABLE TO BE READ, NULL WILL BE RETURNED UNLESS THE STREAM HAS ENDED, IN WHICH CASE ALL OF THE DATA REMAINING IN THE INTERNAL BUFFER WILL BE RETURNED.

IF THE SIZE ARGUMENT IS NOT SPECIFIED, ALL OF THE DATA CONTAINED IN THE INTERNAL BUFFER WILL BE RETURNED.

THE SIZE ARGUMENT MUST BE LESS THAN OR EQUAL TO 1 GIB.

THE READABLE.READ() METHOD SHOULD ONLY BE CALLED ON READABLE STREAMS OPERATING IN PAUSED MODE. IN FLOWING MODE, READABLE.READ() IS CALLED AUTOMATICALLY UNTIL THE INTERNAL BUFFER IS FULLY DRAINED.

CONST READABLE = GETREADABLESTREAMSOMEHOW();

// 'READABLE' MAY BE TRIGGERED MULTIPLE TIMES AS DATA IS BUFFERED IN
READABLE.ON('READABLE', () => {
  LET CHUNK;
  CONSOLE.LOG('STREAM IS READABLE (NEW DATA RECEIVED IN BUFFER)');
  // USE A LOOP TO MAKE SURE WE READ ALL CURRENTLY AVAILABLE DATA
  WHILE (NULL !== (CHUNK = READABLE.READ())) {
    CONSOLE.LOG(`READ ${CHUNK.LENGTH} BYTES OF DATA...`);
  }
});

// 'END' WILL BE TRIGGERED ONCE WHEN THERE IS NO MORE DATA AVAILABLE
READABLE.ON('END', () => {
  CONSOLE.LOG('REACHED END OF STREAM.');
}); COPY
EACH CALL TO READABLE.READ() RETURNS A CHUNK OF DATA, OR NULL. THE CHUNKS ARE NOT CONCATENATED. A WHILE LOOP IS NECESSARY TO CONSUME ALL DATA CURRENTLY IN THE BUFFER. WHEN READING A LARGE FILE .READ() MAY RETURN NULL, HAVING CONSUMED ALL BUFFERED CONTENT SO FAR, BUT THERE IS STILL MORE DATA TO COME NOT YET BUFFERED. IN THIS CASE A NEW 'READABLE' EVENT WILL BE EMITTED WHEN THERE IS MORE DATA IN THE BUFFER. FINALLY THE 'END' EVENT WILL BE EMITTED WHEN THERE IS NO MORE DATA TO COME.

THEREFORE TO READ A FILE'S WHOLE CONTENTS FROM A READABLE, IT IS NECESSARY TO COLLECT CHUNKS ACROSS MULTIPLE 'READABLE' EVENTS:

CONST CHUNKS = [];

READABLE.ON('READABLE', () => {
  LET CHUNK;
  WHILE (NULL !== (CHUNK = READABLE.READ())) {
    CHUNKS.PUSH(CHUNK);
  }
});

READABLE.ON('END', () => {
  CONST CONTENT = CHUNKS.JOIN('');
}); COPY
A READABLE STREAM IN OBJECT MODE WILL ALWAYS RETURN A SINGLE ITEM FROM A CALL TO READABLE.READ(SIZE), REGARDLESS OF THE VALUE OF THE SIZE ARGUMENT.

IF THE READABLE.READ() METHOD RETURNS A CHUNK OF DATA, A 'DATA' EVENT WILL ALSO BE EMITTED.

CALLING STREAM.READ([SIZE]) AFTER THE 'END' EVENT HAS BEEN EMITTED WILL RETURN NULL. NO RUNTIME ERROR WILL BE RAISED.

READABLE.READABLE#
ADDED IN: V11.4.0
<BOOLEAN>
IS TRUE IF IT IS SAFE TO CALL READABLE.READ(), WHICH MEANS THE STREAM HAS NOT BEEN DESTROYED OR EMITTED 'ERROR' OR 'END'.

READABLE.READABLEABORTED#
ADDED IN: V16.8.0
STABILITY: 1 - EXPERIMENTAL
<BOOLEAN>
RETURNS WHETHER THE STREAM WAS DESTROYED OR ERRORED BEFORE EMITTING 'END'.

READABLE.READABLEDIDREAD#
ADDED IN: V16.7.0, V14.18.0
STABILITY: 1 - EXPERIMENTAL
<BOOLEAN>
RETURNS WHETHER 'DATA' HAS BEEN EMITTED.

READABLE.READABLEENCODING#
ADDED IN: V12.7.0
<NULL> | <STRING>
GETTER FOR THE PROPERTY ENCODING OF A GIVEN READABLE STREAM. THE ENCODING PROPERTY CAN BE SET USING THE READABLE.SETENCODING() METHOD.

READABLE.READABLEENDED#
ADDED IN: V12.9.0
<BOOLEAN>
BECOMES TRUE WHEN 'END' EVENT IS EMITTED.

READABLE.ERRORED#
ADDED IN: V18.0.0
<ERROR>
RETURNS ERROR IF THE STREAM HAS BEEN DESTROYED WITH AN ERROR.

READABLE.READABLEFLOWING#
ADDED IN: V9.4.0
<BOOLEAN>
THIS PROPERTY REFLECTS THE CURRENT STATE OF A READABLE STREAM AS DESCRIBED IN THE THREE STATES SECTION.

READABLE.READABLEHIGHWATERMARK#
ADDED IN: V9.3.0
<NUMBER>
RETURNS THE VALUE OF HIGHWATERMARK PASSED WHEN CREATING THIS READABLE.

READABLE.READABLELENGTH#
ADDED IN: V9.4.0
<NUMBER>
THIS PROPERTY CONTAINS THE NUMBER OF BYTES (OR OBJECTS) IN THE QUEUE READY TO BE READ. THE VALUE PROVIDES INTROSPECTION DATA REGARDING THE STATUS OF THE HIGHWATERMARK.

READABLE.READABLEOBJECTMODE#
ADDED IN: V12.3.0
<BOOLEAN>
GETTER FOR THE PROPERTY OBJECTMODE OF A GIVEN READABLE STREAM.

READABLE.RESUME()#
HISTORY
RETURNS: <THIS>
THE READABLE.RESUME() METHOD CAUSES AN EXPLICITLY PAUSED READABLE STREAM TO RESUME EMITTING 'DATA' EVENTS, SWITCHING THE STREAM INTO FLOWING MODE.

THE READABLE.RESUME() METHOD CAN BE USED TO FULLY CONSUME THE DATA FROM A STREAM WITHOUT ACTUALLY PROCESSING ANY OF THAT DATA:

GETREADABLESTREAMSOMEHOW()
  .RESUME()
  .ON('END', () => {
    CONSOLE.LOG('REACHED THE END, BUT DID NOT READ ANYTHING.');
  }); COPY
THE READABLE.RESUME() METHOD HAS NO EFFECT IF THERE IS A 'READABLE' EVENT LISTENER.

READABLE.SETENCODING(ENCODING)#
ADDED IN: V0.9.4
ENCODING <STRING> THE ENCODING TO USE.
RETURNS: <THIS>
THE READABLE.SETENCODING() METHOD SETS THE CHARACTER ENCODING FOR DATA READ FROM THE READABLE STREAM.

BY DEFAULT, NO ENCODING IS ASSIGNED AND STREAM DATA WILL BE RETURNED AS BUFFER OBJECTS. SETTING AN ENCODING CAUSES THE STREAM DATA TO BE RETURNED AS STRINGS OF THE SPECIFIED ENCODING RATHER THAN AS BUFFER OBJECTS. FOR INSTANCE, CALLING READABLE.SETENCODING('UTF8') WILL CAUSE THE OUTPUT DATA TO BE INTERPRETED AS UTF-8 DATA, AND PASSED AS STRINGS. CALLING READABLE.SETENCODING('HEX') WILL CAUSE THE DATA TO BE ENCODED IN HEXADECIMAL STRING FORMAT.

THE READABLE STREAM WILL PROPERLY HANDLE MULTI-BYTE CHARACTERS DELIVERED THROUGH THE STREAM THAT WOULD OTHERWISE BECOME IMPROPERLY DECODED IF SIMPLY PULLED FROM THE STREAM AS BUFFER OBJECTS.

CONST READABLE = GETREADABLESTREAMSOMEHOW();
READABLE.SETENCODING('UTF8');
READABLE.ON('DATA', (CHUNK) => {
  ASSERT.EQUAL(TYPEOF CHUNK, 'STRING');
  CONSOLE.LOG('GOT %D CHARACTERS OF STRING DATA:', CHUNK.LENGTH);
}); COPY
READABLE.UNPIPE([DESTINATION])#
ADDED IN: V0.9.4
DESTINATION <STREAM.WRITABLE> OPTIONAL SPECIFIC STREAM TO UNPIPE
RETURNS: <THIS>
THE READABLE.UNPIPE() METHOD DETACHES A WRITABLE STREAM PREVIOUSLY ATTACHED USING THE STREAM.PIPE() METHOD.

IF THE DESTINATION IS NOT SPECIFIED, THEN ALL PIPES ARE DETACHED.

IF THE DESTINATION IS SPECIFIED, BUT NO PIPE IS SET UP FOR IT, THEN THE METHOD DOES NOTHING.

CONST FS = REQUIRE('NODE:FS');
CONST READABLE = GETREADABLESTREAMSOMEHOW();
CONST WRITABLE = FS.CREATEWRITESTREAM('FILE.TXT');
// ALL THE DATA FROM READABLE GOES INTO 'FILE.TXT',
// BUT ONLY FOR THE FIRST SECOND.
READABLE.PIPE(WRITABLE);
SETTIMEOUT(() => {
  CONSOLE.LOG('STOP WRITING TO FILE.TXT.');
  READABLE.UNPIPE(WRITABLE);
  CONSOLE.LOG('MANUALLY CLOSE THE FILE STREAM.');
  WRITABLE.END();
}, 1000); COPY
READABLE.UNSHIFT(CHUNK[, ENCODING])#
HISTORY
CHUNK <BUFFER> | <UINT8ARRAY> | <STRING> | <NULL> | <ANY> CHUNK OF DATA TO UNSHIFT ONTO THE READ QUEUE. FOR STREAMS NOT OPERATING IN OBJECT MODE, CHUNK MUST BE A STRING, BUFFER, UINT8ARRAY, OR NULL. FOR OBJECT MODE STREAMS, CHUNK MAY BE ANY JAVASCRIPT VALUE.
ENCODING <STRING> ENCODING OF STRING CHUNKS. MUST BE A VALID BUFFER ENCODING, SUCH AS 'UTF8' OR 'ASCII'.
PASSING CHUNK AS NULL SIGNALS THE END OF THE STREAM (EOF) AND BEHAVES THE SAME AS READABLE.PUSH(NULL), AFTER WHICH NO MORE DATA CAN BE WRITTEN. THE EOF SIGNAL IS PUT AT THE END OF THE BUFFER AND ANY BUFFERED DATA WILL STILL BE FLUSHED.

THE READABLE.UNSHIFT() METHOD PUSHES A CHUNK OF DATA BACK INTO THE INTERNAL BUFFER. THIS IS USEFUL IN CERTAIN SITUATIONS WHERE A STREAM IS BEING CONSUMED BY CODE THAT NEEDS TO "UN-CONSUME" SOME AMOUNT OF DATA THAT IT HAS OPTIMISTICALLY PULLED OUT OF THE SOURCE, SO THAT THE DATA CAN BE PASSED ON TO SOME OTHER PARTY.

THE STREAM.UNSHIFT(CHUNK) METHOD CANNOT BE CALLED AFTER THE 'END' EVENT HAS BEEN EMITTED OR A RUNTIME ERROR WILL BE THROWN.

DEVELOPERS USING STREAM.UNSHIFT() OFTEN SHOULD CONSIDER SWITCHING TO USE OF A TRANSFORM STREAM INSTEAD. SEE THE API FOR STREAM IMPLEMENTERS SECTION FOR MORE INFORMATION.

// PULL OFF A HEADER DELIMITED BY \N\N.
// USE UNSHIFT() IF WE GET TOO MUCH.
// CALL THE CALLBACK WITH (ERROR, HEADER, STREAM).
CONST { STRINGDECODER } = REQUIRE('NODE:STRING_DECODER');
FUNCTION PARSEHEADER(STREAM, CALLBACK) {
  STREAM.ON('ERROR', CALLBACK);
  STREAM.ON('READABLE', ONREADABLE);
  CONST DECODER = NEW STRINGDECODER('UTF8');
  LET HEADER = '';
  FUNCTION ONREADABLE() {
    LET CHUNK;
    WHILE (NULL !== (CHUNK = STREAM.READ())) {
      CONST STR = DECODER.WRITE(CHUNK);
      IF (STR.INCLUDES('\N\N')) {
        // FOUND THE HEADER BOUNDARY.
        CONST SPLIT = STR.SPLIT(/\N\N/);
        HEADER += SPLIT.SHIFT();
        CONST REMAINING = SPLIT.JOIN('\N\N');
        CONST BUF = BUFFER.FROM(REMAINING, 'UTF8');
        STREAM.REMOVELISTENER('ERROR', CALLBACK);
        // REMOVE THE 'READABLE' LISTENER BEFORE UNSHIFTING.
        STREAM.REMOVELISTENER('READABLE', ONREADABLE);
        IF (BUF.LENGTH)
          STREAM.UNSHIFT(BUF);
        // NOW THE BODY OF THE MESSAGE CAN BE READ FROM THE STREAM.
        CALLBACK(NULL, HEADER, STREAM);
        RETURN;
      }
      // STILL READING THE HEADER.
      HEADER += STR;
    }
  }
} COPY
UNLIKE STREAM.PUSH(CHUNK), STREAM.UNSHIFT(CHUNK) WILL NOT END THE READING PROCESS BY RESETTING THE INTERNAL READING STATE OF THE STREAM. THIS CAN CAUSE UNEXPECTED RESULTS IF READABLE.UNSHIFT() IS CALLED DURING A READ (I.E. FROM WITHIN A STREAM._READ() IMPLEMENTATION ON A CUSTOM STREAM). FOLLOWING THE CALL TO READABLE.UNSHIFT() WITH AN IMMEDIATE STREAM.PUSH('') WILL RESET THE READING STATE APPROPRIATELY, HOWEVER IT IS BEST TO SIMPLY AVOID CALLING READABLE.UNSHIFT() WHILE IN THE PROCESS OF PERFORMING A READ.

READABLE.WRAP(STREAM)#
ADDED IN: V0.9.4
STREAM <STREAM> AN "OLD STYLE" READABLE STREAM
RETURNS: <THIS>
PRIOR TO NODE.JS 0.10, STREAMS DID NOT IMPLEMENT THE ENTIRE NODE:STREAM MODULE API AS IT IS CURRENTLY DEFINED. (SEE COMPATIBILITY FOR MORE INFORMATION.)

WHEN USING AN OLDER NODE.JS LIBRARY THAT EMITS 'DATA' EVENTS AND HAS A STREAM.PAUSE() METHOD THAT IS ADVISORY ONLY, THE READABLE.WRAP() METHOD CAN BE USED TO CREATE A READABLE STREAM THAT USES THE OLD STREAM AS ITS DATA SOURCE.

IT WILL RARELY BE NECESSARY TO USE READABLE.WRAP() BUT THE METHOD HAS BEEN PROVIDED AS A CONVENIENCE FOR INTERACTING WITH OLDER NODE.JS APPLICATIONS AND LIBRARIES.

CONST { OLDREADER } = REQUIRE('./OLD-API-MODULE.JS');
CONST { READABLE } = REQUIRE('NODE:STREAM');
CONST OREADER = NEW OLDREADER();
CONST MYREADER = NEW READABLE().WRAP(OREADER);

MYREADER.ON('READABLE', () => {
  MYREADER.READ(); // ETC.
}); COPY
READABLE[SYMBOL.ASYNCITERATOR]()#
HISTORY
RETURNS: <ASYNCITERATOR> TO FULLY CONSUME THE STREAM.
CONST FS = REQUIRE('NODE:FS');

ASYNC FUNCTION PRINT(READABLE) {
  READABLE.SETENCODING('UTF8');
  LET DATA = '';
  FOR AWAIT (CONST CHUNK OF READABLE) {
    DATA += CHUNK;
  }
  CONSOLE.LOG(DATA);
}

PRINT(FS.CREATEREADSTREAM('FILE')).CATCH(CONSOLE.ERROR); COPY
IF THE LOOP TERMINATES WITH A BREAK, RETURN, OR A THROW, THE STREAM WILL BE DESTROYED. IN OTHER TERMS, ITERATING OVER A STREAM WILL CONSUME THE STREAM FULLY. THE STREAM WILL BE READ IN CHUNKS OF SIZE EQUAL TO THE HIGHWATERMARK OPTION. IN THE CODE EXAMPLE ABOVE, DATA WILL BE IN A SINGLE CHUNK IF THE FILE HAS LESS THEN 64 KIB OF DATA BECAUSE NO HIGHWATERMARK OPTION IS PROVIDED TO FS.CREATEREADSTREAM().

READABLE.COMPOSE(STREAM[, OPTIONS])#
ADDED IN: V19.1.0
STABILITY: 1 - EXPERIMENTAL
STREAM <STREAM> | <ITERABLE> | <ASYNCITERABLE> | <FUNCTION>
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ALLOWS DESTROYING THE STREAM IF THE SIGNAL IS ABORTED.
RETURNS: <DUPLEX> A STREAM COMPOSED WITH THE STREAM STREAM.
IMPORT { READABLE } FROM 'NODE:STREAM';

ASYNC FUNCTION* SPLITTOWORDS(SOURCE) {
  FOR AWAIT (CONST CHUNK OF SOURCE) {
    CONST WORDS = STRING(CHUNK).SPLIT(' ');

    FOR (CONST WORD OF WORDS) {
      YIELD WORD;
    }
  }
}

CONST WORDSSTREAM = READABLE.FROM(['THIS IS', 'COMPOSE AS OPERATOR']).COMPOSE(SPLITTOWORDS);
CONST WORDS = AWAIT WORDSSTREAM.TOARRAY();

CONSOLE.LOG(WORDS); // PRINTS ['THIS', 'IS', 'COMPOSE', 'AS', 'OPERATOR'] COPY
SEE STREAM.COMPOSE FOR MORE INFORMATION.

READABLE.ITERATOR([OPTIONS])#
ADDED IN: V16.3.0
STABILITY: 1 - EXPERIMENTAL
OPTIONS <OBJECT>
DESTROYONRETURN <BOOLEAN> WHEN SET TO FALSE, CALLING RETURN ON THE ASYNC ITERATOR, OR EXITING A FOR AWAIT...OF ITERATION USING A BREAK, RETURN, OR THROW WILL NOT DESTROY THE STREAM. DEFAULT: TRUE.
RETURNS: <ASYNCITERATOR> TO CONSUME THE STREAM.
THE ITERATOR CREATED BY THIS METHOD GIVES USERS THE OPTION TO CANCEL THE DESTRUCTION OF THE STREAM IF THE FOR AWAIT...OF LOOP IS EXITED BY RETURN, BREAK, OR THROW, OR IF THE ITERATOR SHOULD DESTROY THE STREAM IF THE STREAM EMITTED AN ERROR DURING ITERATION.

CONST { READABLE } = REQUIRE('NODE:STREAM');

ASYNC FUNCTION PRINTITERATOR(READABLE) {
  FOR AWAIT (CONST CHUNK OF READABLE.ITERATOR({ DESTROYONRETURN: FALSE })) {
    CONSOLE.LOG(CHUNK); // 1
    BREAK;
  }

  CONSOLE.LOG(READABLE.DESTROYED); // FALSE

  FOR AWAIT (CONST CHUNK OF READABLE.ITERATOR({ DESTROYONRETURN: FALSE })) {
    CONSOLE.LOG(CHUNK); // WILL PRINT 2 AND THEN 3
  }

  CONSOLE.LOG(READABLE.DESTROYED); // TRUE, STREAM WAS TOTALLY CONSUMED
}

ASYNC FUNCTION PRINTSYMBOLASYNCITERATOR(READABLE) {
  FOR AWAIT (CONST CHUNK OF READABLE) {
    CONSOLE.LOG(CHUNK); // 1
    BREAK;
  }

  CONSOLE.LOG(READABLE.DESTROYED); // TRUE
}

ASYNC FUNCTION SHOWBOTH() {
  AWAIT PRINTITERATOR(READABLE.FROM([1, 2, 3]));
  AWAIT PRINTSYMBOLASYNCITERATOR(READABLE.FROM([1, 2, 3]));
}

SHOWBOTH(); COPY
READABLE.MAP(FN[, OPTIONS])#
ADDED IN: V17.4.0, V16.14.0
STABILITY: 1 - EXPERIMENTAL
FN <FUNCTION> | <ASYNCFUNCTION> A FUNCTION TO MAP OVER EVERY CHUNK IN THE STREAM.
DATA <ANY> A CHUNK OF DATA FROM THE STREAM.
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ABORTED IF THE STREAM IS DESTROYED ALLOWING TO ABORT THE FN CALL EARLY.
OPTIONS <OBJECT>
CONCURRENCY <NUMBER> THE MAXIMUM CONCURRENT INVOCATION OF FN TO CALL ON THE STREAM AT ONCE. DEFAULT: 1.
SIGNAL <ABORTSIGNAL> ALLOWS DESTROYING THE STREAM IF THE SIGNAL IS ABORTED.
RETURNS: <READABLE> A STREAM MAPPED WITH THE FUNCTION FN.
THIS METHOD ALLOWS MAPPING OVER THE STREAM. THE FN FUNCTION WILL BE CALLED FOR EVERY CHUNK IN THE STREAM. IF THE FN FUNCTION RETURNS A PROMISE - THAT PROMISE WILL BE AWAITED BEFORE BEING PASSED TO THE RESULT STREAM.

IMPORT { READABLE } FROM 'NODE:STREAM';
IMPORT { RESOLVER } FROM 'NODE:DNS/PROMISES';

// WITH A SYNCHRONOUS MAPPER.
FOR AWAIT (CONST CHUNK OF READABLE.FROM([1, 2, 3, 4]).MAP((X) => X * 2)) {
  CONSOLE.LOG(CHUNK); // 2, 4, 6, 8
}
// WITH AN ASYNCHRONOUS MAPPER, MAKING AT MOST 2 QUERIES AT A TIME.
CONST RESOLVER = NEW RESOLVER();
CONST DNSRESULTS = READABLE.FROM([
  'NODEJS.ORG',
  'OPENJSF.ORG',
  'WWW.LINUXFOUNDATION.ORG',
]).MAP((DOMAIN) => RESOLVER.RESOLVE4(DOMAIN), { CONCURRENCY: 2 });
FOR AWAIT (CONST RESULT OF DNSRESULTS) {
  CONSOLE.LOG(RESULT); // LOGS THE DNS RESULT OF RESOLVER.RESOLVE4.
} COPY
READABLE.FILTER(FN[, OPTIONS])#
ADDED IN: V17.4.0, V16.14.0
STABILITY: 1 - EXPERIMENTAL
FN <FUNCTION> | <ASYNCFUNCTION> A FUNCTION TO FILTER CHUNKS FROM THE STREAM.
DATA <ANY> A CHUNK OF DATA FROM THE STREAM.
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ABORTED IF THE STREAM IS DESTROYED ALLOWING TO ABORT THE FN CALL EARLY.
OPTIONS <OBJECT>
CONCURRENCY <NUMBER> THE MAXIMUM CONCURRENT INVOCATION OF FN TO CALL ON THE STREAM AT ONCE. DEFAULT: 1.
SIGNAL <ABORTSIGNAL> ALLOWS DESTROYING THE STREAM IF THE SIGNAL IS ABORTED.
RETURNS: <READABLE> A STREAM FILTERED WITH THE PREDICATE FN.
THIS METHOD ALLOWS FILTERING THE STREAM. FOR EACH CHUNK IN THE STREAM THE FN FUNCTION WILL BE CALLED AND IF IT RETURNS A TRUTHY VALUE, THE CHUNK WILL BE PASSED TO THE RESULT STREAM. IF THE FN FUNCTION RETURNS A PROMISE - THAT PROMISE WILL BE AWAITED.

IMPORT { READABLE } FROM 'NODE:STREAM';
IMPORT { RESOLVER } FROM 'NODE:DNS/PROMISES';

// WITH A SYNCHRONOUS PREDICATE.
FOR AWAIT (CONST CHUNK OF READABLE.FROM([1, 2, 3, 4]).FILTER((X) => X > 2)) {
  CONSOLE.LOG(CHUNK); // 3, 4
}
// WITH AN ASYNCHRONOUS PREDICATE, MAKING AT MOST 2 QUERIES AT A TIME.
CONST RESOLVER = NEW RESOLVER();
CONST DNSRESULTS = READABLE.FROM([
  'NODEJS.ORG',
  'OPENJSF.ORG',
  'WWW.LINUXFOUNDATION.ORG',
]).FILTER(ASYNC (DOMAIN) => {
  CONST { ADDRESS } = AWAIT RESOLVER.RESOLVE4(DOMAIN, { TTL: TRUE });
  RETURN ADDRESS.TTL > 60;
}, { CONCURRENCY: 2 });
FOR AWAIT (CONST RESULT OF DNSRESULTS) {
  // LOGS DOMAINS WITH MORE THAN 60 SECONDS ON THE RESOLVED DNS RECORD.
  CONSOLE.LOG(RESULT);
} COPY
READABLE.FOREACH(FN[, OPTIONS])#
ADDED IN: V17.5.0, V16.15.0
STABILITY: 1 - EXPERIMENTAL
FN <FUNCTION> | <ASYNCFUNCTION> A FUNCTION TO CALL ON EACH CHUNK OF THE STREAM.
DATA <ANY> A CHUNK OF DATA FROM THE STREAM.
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ABORTED IF THE STREAM IS DESTROYED ALLOWING TO ABORT THE FN CALL EARLY.
OPTIONS <OBJECT>
CONCURRENCY <NUMBER> THE MAXIMUM CONCURRENT INVOCATION OF FN TO CALL ON THE STREAM AT ONCE. DEFAULT: 1.
SIGNAL <ABORTSIGNAL> ALLOWS DESTROYING THE STREAM IF THE SIGNAL IS ABORTED.
RETURNS: <PROMISE> A PROMISE FOR WHEN THE STREAM HAS FINISHED.
THIS METHOD ALLOWS ITERATING A STREAM. FOR EACH CHUNK IN THE STREAM THE FN FUNCTION WILL BE CALLED. IF THE FN FUNCTION RETURNS A PROMISE - THAT PROMISE WILL BE AWAITED.

THIS METHOD IS DIFFERENT FROM FOR AWAIT...OF LOOPS IN THAT IT CAN OPTIONALLY PROCESS CHUNKS CONCURRENTLY. IN ADDITION, A FOREACH ITERATION CAN ONLY BE STOPPED BY HAVING PASSED A SIGNAL OPTION AND ABORTING THE RELATED ABORTCONTROLLER WHILE FOR AWAIT...OF CAN BE STOPPED WITH BREAK OR RETURN. IN EITHER CASE THE STREAM WILL BE DESTROYED.

THIS METHOD IS DIFFERENT FROM LISTENING TO THE 'DATA' EVENT IN THAT IT USES THE READABLE EVENT IN THE UNDERLYING MACHINARY AND CAN LIMIT THE NUMBER OF CONCURRENT FN CALLS.

IMPORT { READABLE } FROM 'NODE:STREAM';
IMPORT { RESOLVER } FROM 'NODE:DNS/PROMISES';

// WITH A SYNCHRONOUS PREDICATE.
FOR AWAIT (CONST CHUNK OF READABLE.FROM([1, 2, 3, 4]).FILTER((X) => X > 2)) {
  CONSOLE.LOG(CHUNK); // 3, 4
}
// WITH AN ASYNCHRONOUS PREDICATE, MAKING AT MOST 2 QUERIES AT A TIME.
CONST RESOLVER = NEW RESOLVER();
CONST DNSRESULTS = READABLE.FROM([
  'NODEJS.ORG',
  'OPENJSF.ORG',
  'WWW.LINUXFOUNDATION.ORG',
]).MAP(ASYNC (DOMAIN) => {
  CONST { ADDRESS } = AWAIT RESOLVER.RESOLVE4(DOMAIN, { TTL: TRUE });
  RETURN ADDRESS;
}, { CONCURRENCY: 2 });
AWAIT DNSRESULTS.FOREACH((RESULT) => {
  // LOGS RESULT, SIMILAR TO `FOR AWAIT (CONST RESULT OF DNSRESULTS)`
  CONSOLE.LOG(RESULT);
});
CONSOLE.LOG('DONE'); // STREAM HAS FINISHED COPY
READABLE.TOARRAY([OPTIONS])#
ADDED IN: V17.5.0, V16.15.0
STABILITY: 1 - EXPERIMENTAL
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ALLOWS CANCELLING THE TOARRAY OPERATION IF THE SIGNAL IS ABORTED.
RETURNS: <PROMISE> A PROMISE CONTAINING AN ARRAY WITH THE CONTENTS OF THE STREAM.
THIS METHOD ALLOWS EASILY OBTAINING THE CONTENTS OF A STREAM.

AS THIS METHOD READS THE ENTIRE STREAM INTO MEMORY, IT NEGATES THE BENEFITS OF STREAMS. IT'S INTENDED FOR INTEROPERABILITY AND CONVENIENCE, NOT AS THE PRIMARY WAY TO CONSUME STREAMS.

IMPORT { READABLE } FROM 'NODE:STREAM';
IMPORT { RESOLVER } FROM 'NODE:DNS/PROMISES';

AWAIT READABLE.FROM([1, 2, 3, 4]).TOARRAY(); // [1, 2, 3, 4]

// MAKE DNS QUERIES CONCURRENTLY USING .MAP AND COLLECT
// THE RESULTS INTO AN ARRAY USING TOARRAY
CONST DNSRESULTS = AWAIT READABLE.FROM([
  'NODEJS.ORG',
  'OPENJSF.ORG',
  'WWW.LINUXFOUNDATION.ORG',
]).MAP(ASYNC (DOMAIN) => {
  CONST { ADDRESS } = AWAIT RESOLVER.RESOLVE4(DOMAIN, { TTL: TRUE });
  RETURN ADDRESS;
}, { CONCURRENCY: 2 }).TOARRAY(); COPY
READABLE.SOME(FN[, OPTIONS])#
ADDED IN: V17.5.0, V16.15.0
STABILITY: 1 - EXPERIMENTAL
FN <FUNCTION> | <ASYNCFUNCTION> A FUNCTION TO CALL ON EACH CHUNK OF THE STREAM.
DATA <ANY> A CHUNK OF DATA FROM THE STREAM.
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ABORTED IF THE STREAM IS DESTROYED ALLOWING TO ABORT THE FN CALL EARLY.
OPTIONS <OBJECT>
CONCURRENCY <NUMBER> THE MAXIMUM CONCURRENT INVOCATION OF FN TO CALL ON THE STREAM AT ONCE. DEFAULT: 1.
SIGNAL <ABORTSIGNAL> ALLOWS DESTROYING THE STREAM IF THE SIGNAL IS ABORTED.
RETURNS: <PROMISE> A PROMISE EVALUATING TO TRUE IF FN RETURNED A TRUTHY VALUE FOR AT LEAST ONE OF THE CHUNKS.
THIS METHOD IS SIMILAR TO ARRAY.PROTOTYPE.SOME AND CALLS FN ON EACH CHUNK IN THE STREAM UNTIL THE AWAITED RETURN VALUE IS TRUE (OR ANY TRUTHY VALUE). ONCE AN FN CALL ON A CHUNK AWAITED RETURN VALUE IS TRUTHY, THE STREAM IS DESTROYED AND THE PROMISE IS FULFILLED WITH TRUE. IF NONE OF THE FN CALLS ON THE CHUNKS RETURN A TRUTHY VALUE, THE PROMISE IS FULFILLED WITH FALSE.

IMPORT { READABLE } FROM 'NODE:STREAM';
IMPORT { STAT } FROM 'NODE:FS/PROMISES';

// WITH A SYNCHRONOUS PREDICATE.
AWAIT READABLE.FROM([1, 2, 3, 4]).SOME((X) => X > 2); // TRUE
AWAIT READABLE.FROM([1, 2, 3, 4]).SOME((X) => X < 0); // FALSE

// WITH AN ASYNCHRONOUS PREDICATE, MAKING AT MOST 2 FILE CHECKS AT A TIME.
CONST ANYBIGFILE = AWAIT READABLE.FROM([
  'FILE1',
  'FILE2',
  'FILE3',
]).SOME(ASYNC (FILENAME) => {
  CONST STATS = AWAIT STAT(FILENAME);
  RETURN STATS.SIZE > 1024 * 1024;
}, { CONCURRENCY: 2 });
CONSOLE.LOG(ANYBIGFILE); // `TRUE` IF ANY FILE IN THE LIST IS BIGGER THAN 1MB
CONSOLE.LOG('DONE'); // STREAM HAS FINISHED COPY
READABLE.FIND(FN[, OPTIONS])#
ADDED IN: V17.5.0, V16.17.0
STABILITY: 1 - EXPERIMENTAL
FN <FUNCTION> | <ASYNCFUNCTION> A FUNCTION TO CALL ON EACH CHUNK OF THE STREAM.
DATA <ANY> A CHUNK OF DATA FROM THE STREAM.
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ABORTED IF THE STREAM IS DESTROYED ALLOWING TO ABORT THE FN CALL EARLY.
OPTIONS <OBJECT>
CONCURRENCY <NUMBER> THE MAXIMUM CONCURRENT INVOCATION OF FN TO CALL ON THE STREAM AT ONCE. DEFAULT: 1.
SIGNAL <ABORTSIGNAL> ALLOWS DESTROYING THE STREAM IF THE SIGNAL IS ABORTED.
RETURNS: <PROMISE> A PROMISE EVALUATING TO THE FIRST CHUNK FOR WHICH FN EVALUATED WITH A TRUTHY VALUE, OR UNDEFINED IF NO ELEMENT WAS FOUND.
THIS METHOD IS SIMILAR TO ARRAY.PROTOTYPE.FIND AND CALLS FN ON EACH CHUNK IN THE STREAM TO FIND A CHUNK WITH A TRUTHY VALUE FOR FN. ONCE AN FN CALL'S AWAITED RETURN VALUE IS TRUTHY, THE STREAM IS DESTROYED AND THE PROMISE IS FULFILLED WITH VALUE FOR WHICH FN RETURNED A TRUTHY VALUE. IF ALL OF THE FN CALLS ON THE CHUNKS RETURN A FALSY VALUE, THE PROMISE IS FULFILLED WITH UNDEFINED.

IMPORT { READABLE } FROM 'NODE:STREAM';
IMPORT { STAT } FROM 'NODE:FS/PROMISES';

// WITH A SYNCHRONOUS PREDICATE.
AWAIT READABLE.FROM([1, 2, 3, 4]).FIND((X) => X > 2); // 3
AWAIT READABLE.FROM([1, 2, 3, 4]).FIND((X) => X > 0); // 1
AWAIT READABLE.FROM([1, 2, 3, 4]).FIND((X) => X > 10); // UNDEFINED

// WITH AN ASYNCHRONOUS PREDICATE, MAKING AT MOST 2 FILE CHECKS AT A TIME.
CONST FOUNDBIGFILE = AWAIT READABLE.FROM([
  'FILE1',
  'FILE2',
  'FILE3',
]).FIND(ASYNC (FILENAME) => {
  CONST STATS = AWAIT STAT(FILENAME);
  RETURN STATS.SIZE > 1024 * 1024;
}, { CONCURRENCY: 2 });
CONSOLE.LOG(FOUNDBIGFILE); // FILE NAME OF LARGE FILE, IF ANY FILE IN THE LIST IS BIGGER THAN 1MB
CONSOLE.LOG('DONE'); // STREAM HAS FINISHED COPY
READABLE.EVERY(FN[, OPTIONS])#
ADDED IN: V17.5.0, V16.15.0
STABILITY: 1 - EXPERIMENTAL
FN <FUNCTION> | <ASYNCFUNCTION> A FUNCTION TO CALL ON EACH CHUNK OF THE STREAM.
DATA <ANY> A CHUNK OF DATA FROM THE STREAM.
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ABORTED IF THE STREAM IS DESTROYED ALLOWING TO ABORT THE FN CALL EARLY.
OPTIONS <OBJECT>
CONCURRENCY <NUMBER> THE MAXIMUM CONCURRENT INVOCATION OF FN TO CALL ON THE STREAM AT ONCE. DEFAULT: 1.
SIGNAL <ABORTSIGNAL> ALLOWS DESTROYING THE STREAM IF THE SIGNAL IS ABORTED.
RETURNS: <PROMISE> A PROMISE EVALUATING TO TRUE IF FN RETURNED A TRUTHY VALUE FOR ALL OF THE CHUNKS.
THIS METHOD IS SIMILAR TO ARRAY.PROTOTYPE.EVERY AND CALLS FN ON EACH CHUNK IN THE STREAM TO CHECK IF ALL AWAITED RETURN VALUES ARE TRUTHY VALUE FOR FN. ONCE AN FN CALL ON A CHUNK AWAITED RETURN VALUE IS FALSY, THE STREAM IS DESTROYED AND THE PROMISE IS FULFILLED WITH FALSE. IF ALL OF THE FN CALLS ON THE CHUNKS RETURN A TRUTHY VALUE, THE PROMISE IS FULFILLED WITH TRUE.

IMPORT { READABLE } FROM 'NODE:STREAM';
IMPORT { STAT } FROM 'NODE:FS/PROMISES';

// WITH A SYNCHRONOUS PREDICATE.
AWAIT READABLE.FROM([1, 2, 3, 4]).EVERY((X) => X > 2); // FALSE
AWAIT READABLE.FROM([1, 2, 3, 4]).EVERY((X) => X > 0); // TRUE

// WITH AN ASYNCHRONOUS PREDICATE, MAKING AT MOST 2 FILE CHECKS AT A TIME.
CONST ALLBIGFILES = AWAIT READABLE.FROM([
  'FILE1',
  'FILE2',
  'FILE3',
]).EVERY(ASYNC (FILENAME) => {
  CONST STATS = AWAIT STAT(FILENAME);
  RETURN STATS.SIZE > 1024 * 1024;
}, { CONCURRENCY: 2 });
// `TRUE` IF ALL FILES IN THE LIST ARE BIGGER THAN 1MIB
CONSOLE.LOG(ALLBIGFILES);
CONSOLE.LOG('DONE'); // STREAM HAS FINISHED COPY
READABLE.FLATMAP(FN[, OPTIONS])#
ADDED IN: V17.5.0, V16.15.0
STABILITY: 1 - EXPERIMENTAL
FN <FUNCTION> | <ASYNCGENERATORFUNCTION> | <ASYNCFUNCTION> A FUNCTION TO MAP OVER EVERY CHUNK IN THE STREAM.
DATA <ANY> A CHUNK OF DATA FROM THE STREAM.
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ABORTED IF THE STREAM IS DESTROYED ALLOWING TO ABORT THE FN CALL EARLY.
OPTIONS <OBJECT>
CONCURRENCY <NUMBER> THE MAXIMUM CONCURRENT INVOCATION OF FN TO CALL ON THE STREAM AT ONCE. DEFAULT: 1.
SIGNAL <ABORTSIGNAL> ALLOWS DESTROYING THE STREAM IF THE SIGNAL IS ABORTED.
RETURNS: <READABLE> A STREAM FLAT-MAPPED WITH THE FUNCTION FN.
THIS METHOD RETURNS A NEW STREAM BY APPLYING THE GIVEN CALLBACK TO EACH CHUNK OF THE STREAM AND THEN FLATTENING THE RESULT.

IT IS POSSIBLE TO RETURN A STREAM OR ANOTHER ITERABLE OR ASYNC ITERABLE FROM FN AND THE RESULT STREAMS WILL BE MERGED (FLATTENED) INTO THE RETURNED STREAM.

IMPORT { READABLE } FROM 'NODE:STREAM';
IMPORT { CREATEREADSTREAM } FROM 'NODE:FS';

// WITH A SYNCHRONOUS MAPPER.
FOR AWAIT (CONST CHUNK OF READABLE.FROM([1, 2, 3, 4]).FLATMAP((X) => [X, X])) {
  CONSOLE.LOG(CHUNK); // 1, 1, 2, 2, 3, 3, 4, 4
}
// WITH AN ASYNCHRONOUS MAPPER, COMBINE THE CONTENTS OF 4 FILES
CONST CONCATRESULT = READABLE.FROM([
  './1.MJS',
  './2.MJS',
  './3.MJS',
  './4.MJS',
]).FLATMAP((FILENAME) => CREATEREADSTREAM(FILENAME));
FOR AWAIT (CONST RESULT OF CONCATRESULT) {
  // THIS WILL CONTAIN THE CONTENTS (ALL CHUNKS) OF ALL 4 FILES
  CONSOLE.LOG(RESULT);
} COPY
READABLE.DROP(LIMIT[, OPTIONS])#
ADDED IN: V17.5.0, V16.15.0
STABILITY: 1 - EXPERIMENTAL
LIMIT <NUMBER> THE NUMBER OF CHUNKS TO DROP FROM THE READABLE.
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ALLOWS DESTROYING THE STREAM IF THE SIGNAL IS ABORTED.
RETURNS: <READABLE> A STREAM WITH LIMIT CHUNKS DROPPED.
THIS METHOD RETURNS A NEW STREAM WITH THE FIRST LIMIT CHUNKS DROPPED.

IMPORT { READABLE } FROM 'NODE:STREAM';

AWAIT READABLE.FROM([1, 2, 3, 4]).DROP(2).TOARRAY(); // [3, 4] COPY
READABLE.TAKE(LIMIT[, OPTIONS])#
ADDED IN: V17.5.0, V16.15.0
STABILITY: 1 - EXPERIMENTAL
LIMIT <NUMBER> THE NUMBER OF CHUNKS TO TAKE FROM THE READABLE.
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ALLOWS DESTROYING THE STREAM IF THE SIGNAL IS ABORTED.
RETURNS: <READABLE> A STREAM WITH LIMIT CHUNKS TAKEN.
THIS METHOD RETURNS A NEW STREAM WITH THE FIRST LIMIT CHUNKS.

IMPORT { READABLE } FROM 'NODE:STREAM';

AWAIT READABLE.FROM([1, 2, 3, 4]).TAKE(2).TOARRAY(); // [1, 2] COPY
READABLE.ASINDEXEDPAIRS([OPTIONS])#
ADDED IN: V17.5.0, V16.15.0
STABILITY: 1 - EXPERIMENTAL
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ALLOWS DESTROYING THE STREAM IF THE SIGNAL IS ABORTED.
RETURNS: <READABLE> A STREAM OF INDEXED PAIRS.
THIS METHOD RETURNS A NEW STREAM WITH CHUNKS OF THE UNDERLYING STREAM PAIRED WITH A COUNTER IN THE FORM [INDEX, CHUNK]. THE FIRST INDEX VALUE IS 0 AND IT INCREASES BY 1 FOR EACH CHUNK PRODUCED.

IMPORT { READABLE } FROM 'NODE:STREAM';

CONST PAIRS = AWAIT READABLE.FROM(['A', 'B', 'C']).ASINDEXEDPAIRS().TOARRAY();
CONSOLE.LOG(PAIRS); // [[0, 'A'], [1, 'B'], [2, 'C']] COPY
READABLE.REDUCE(FN[, INITIAL[, OPTIONS]])#
ADDED IN: V17.5.0, V16.15.0
STABILITY: 1 - EXPERIMENTAL
FN <FUNCTION> | <ASYNCFUNCTION> A REDUCER FUNCTION TO CALL OVER EVERY CHUNK IN THE STREAM.
PREVIOUS <ANY> THE VALUE OBTAINED FROM THE LAST CALL TO FN OR THE INITIAL VALUE IF SPECIFIED OR THE FIRST CHUNK OF THE STREAM OTHERWISE.
DATA <ANY> A CHUNK OF DATA FROM THE STREAM.
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ABORTED IF THE STREAM IS DESTROYED ALLOWING TO ABORT THE FN CALL EARLY.
INITIAL <ANY> THE INITIAL VALUE TO USE IN THE REDUCTION.
OPTIONS <OBJECT>
SIGNAL <ABORTSIGNAL> ALLOWS DESTROYING THE STREAM IF THE SIGNAL IS ABORTED.
RETURNS: <PROMISE> A PROMISE FOR THE FINAL VALUE OF THE REDUCTION.
THIS METHOD CALLS FN ON EACH CHUNK OF THE STREAM IN ORDER, PASSING IT THE RESULT FROM THE CALCULATION ON THE PREVIOUS ELEMENT. IT RETURNS A PROMISE FOR THE FINAL VALUE OF THE REDUCTION.

IF NO INITIAL VALUE IS SUPPLIED THE FIRST CHUNK OF THE STREAM IS USED AS THE INITIAL VALUE. IF THE STREAM IS EMPTY, THE PROMISE IS REJECTED WITH A TYPEERROR WITH THE ERR_INVALID_ARGS CODE PROPERTY.

IMPORT { READABLE } FROM 'NODE:STREAM';
IMPORT { READDIR, STAT } FROM 'NODE:FS/PROMISES';
IMPORT { JOIN } FROM 'NODE:PATH';

CONST DIRECTORYPATH = './SRC';
CONST FILESINDIR = AWAIT READDIR(DIRECTORYPATH);

CONST FOLDERSIZE = AWAIT READABLE.FROM(FILESINDIR)
  .REDUCE(ASYNC (TOTALSIZE, FILE) => {
    CONST { SIZE } = AWAIT STAT(JOIN(DIRECTORYPATH, FILE));
    RETURN TOTALSIZE + SIZE;
  }, 0);

CONSOLE.LOG(FOLDERSIZE); COPY
THE REDUCER FUNCTION ITERATES THE STREAM ELEMENT-BY-ELEMENT WHICH MEANS THAT THERE IS NO CONCURRENCY PARAMETER OR PARALLELISM. TO PERFORM A REDUCE CONCURRENTLY, YOU CAN EXTRACT THE ASYNC FUNCTION TO READABLE.MAP METHOD.

IMPORT { READABLE } FROM 'NODE:STREAM';
IMPORT { READDIR, STAT } FROM 'NODE:FS/PROMISES';
IMPORT { JOIN } FROM 'NODE:PATH';

CONST DIRECTORYPATH = './SRC';
CONST FILESINDIR = AWAIT READDIR(DIRECTORYPATH);

CONST FOLDERSIZE = AWAIT READABLE.FROM(FILESINDIR)
  .MAP((FILE) => STAT(JOIN(DIRECTORYPATH, FILE)), { CONCURRENCY: 2 })
  .REDUCE((TOTALSIZE, { SIZE }) => TOTALSIZE + SIZE, 0);

CONSOLE.LOG(FOLDERSIZE); COPY
DUPLEX AND TRANSFORM STREAMS#
CLASS: STREAM.DUPLEX#
HISTORY
DUPLEX STREAMS ARE STREAMS THAT IMPLEMENT BOTH THE READABLE AND WRITABLE INTERFACES.

EXAMPLES OF DUPLEX STREAMS INCLUDE:

TCP SOCKETS
ZLIB STREAMS
CRYPTO STREAMS
DUPLEX.ALLOWHALFOPEN#
ADDED IN: V0.9.4
<BOOLEAN>
IF FALSE THEN THE STREAM WILL AUTOMATICALLY END THE WRITABLE SIDE WHEN THE READABLE SIDE ENDS. SET INITIALLY BY THE ALLOWHALFOPEN CONSTRUCTOR OPTION, WHICH DEFAULTS TO TRUE.

THIS CAN BE CHANGED MANUALLY TO CHANGE THE HALF-OPEN BEHAVIOR OF AN EXISTING DUPLEX STREAM INSTANCE, BUT MUST BE CHANGED BEFORE THE 'END' EVENT IS EMITTED.

CLASS: STREAM.TRANSFORM#
ADDED IN: V0.9.4
TRANSFORM STREAMS ARE DUPLEX STREAMS WHERE THE OUTPUT IS IN SOME WAY RELATED TO THE INPUT. LIKE ALL DUPLEX STREAMS, TRANSFORM STREAMS IMPLEMENT BOTH THE READABLE AND WRITABLE INTERFACES.

EXAMPLES OF TRANSFORM STREAMS INCLUDE:

ZLIB STREAMS
CRYPTO STREAMS
TRANSFORM.DESTROY([ERROR])#
HISTORY
ERROR <ERROR>
RETURNS: <THIS>
DESTROY THE STREAM, AND OPTIONALLY EMIT AN 'ERROR' EVENT. AFTER THIS CALL, THE TRANSFORM STREAM WOULD RELEASE ANY INTERNAL RESOURCES. IMPLEMENTORS SHOULD NOT OVERRIDE THIS METHOD, BUT INSTEAD IMPLEMENT READABLE._DESTROY(). THE DEFAULT IMPLEMENTATION OF _DESTROY() FOR TRANSFORM ALSO EMIT 'CLOSE' UNLESS EMITCLOSE IS SET IN FALSE.

ONCE DESTROY() HAS BEEN CALLED, ANY FURTHER CALLS WILL BE A NO-OP AND NO FURTHER ERRORS EXCEPT FROM _DESTROY() MAY BE EMITTED AS 'ERROR'.

STREAM.FINISHED(STREAM[, OPTIONS], CALLBACK)#
HISTORY
STREAM <STREAM> | <READABLESTREAM> | <WRITABLESTREAM>
A READABLE AND/OR WRITABLE STREAM/WEBSTREAM.

OPTIONS <OBJECT>

ERROR <BOOLEAN> IF SET TO FALSE, THEN A CALL TO EMIT('ERROR', ERR) IS NOT TREATED AS FINISHED. DEFAULT: TRUE.
READABLE <BOOLEAN> WHEN SET TO FALSE, THE CALLBACK WILL BE CALLED WHEN THE STREAM ENDS EVEN THOUGH THE STREAM MIGHT STILL BE READABLE. DEFAULT: TRUE.
WRITABLE <BOOLEAN> WHEN SET TO FALSE, THE CALLBACK WILL BE CALLED WHEN THE STREAM ENDS EVEN THOUGH THE STREAM MIGHT STILL BE WRITABLE. DEFAULT: TRUE.
SIGNAL <ABORTSIGNAL> ALLOWS ABORTING THE WAIT FOR THE STREAM FINISH. THE UNDERLYING STREAM WILL NOT BE ABORTED IF THE SIGNAL IS ABORTED. THE CALLBACK WILL GET CALLED WITH AN ABORTERROR. ALL REGISTERED LISTENERS ADDED BY THIS FUNCTION WILL ALSO BE REMOVED.
CLEANUP <BOOLEAN> REMOVE ALL REGISTERED STREAM LISTENERS. DEFAULT: FALSE.
CALLBACK <FUNCTION> A CALLBACK FUNCTION THAT TAKES AN OPTIONAL ERROR ARGUMENT.

RETURNS: <FUNCTION> A CLEANUP FUNCTION WHICH REMOVES ALL REGISTERED LISTENERS.

A FUNCTION TO GET NOTIFIED WHEN A STREAM IS NO LONGER READABLE, WRITABLE OR HAS EXPERIENCED AN ERROR OR A PREMATURE CLOSE EVENT.

CONST { FINISHED } = REQUIRE('NODE:STREAM');
CONST FS = REQUIRE('NODE:FS');

CONST RS = FS.CREATEREADSTREAM('ARCHIVE.TAR');

FINISHED(RS, (ERR) => {
  IF (ERR) {
    CONSOLE.ERROR('STREAM FAILED.', ERR);
  } ELSE {
    CONSOLE.LOG('STREAM IS DONE READING.');
  }
});

RS.RESUME(); // DRAIN THE STREAM. COPY
ESPECIALLY USEFUL IN ERROR HANDLING SCENARIOS WHERE A STREAM IS DESTROYED PREMATURELY (LIKE AN ABORTED HTTP REQUEST), AND WILL NOT EMIT 'END' OR 'FINISH'.

THE FINISHED API PROVIDES PROMISE VERSION.

STREAM.FINISHED() LEAVES DANGLING EVENT LISTENERS (IN PARTICULAR 'ERROR', 'END', 'FINISH' AND 'CLOSE') AFTER CALLBACK HAS BEEN INVOKED. THE REASON FOR THIS IS SO THAT UNEXPECTED 'ERROR' EVENTS (DUE TO INCORRECT STREAM IMPLEMENTATIONS) DO NOT CAUSE UNEXPECTED CRASHES. IF THIS IS UNWANTED BEHAVIOR THEN THE RETURNED CLEANUP FUNCTION NEEDS TO BE INVOKED IN THE CALLBACK:

CONST CLEANUP = FINISHED(RS, (ERR) => {
  CLEANUP();
  // ...
}); COPY
STREAM.PIPELINE(SOURCE[, ...TRANSFORMS], DESTINATION, CALLBACK)#
STREAM.PIPELINE(STREAMS, CALLBACK)#
HISTORY
STREAMS <STREAM[]> | <ITERABLE[]> | <ASYNCITERABLE[]> | <FUNCTION[]> | <READABLESTREAM[]> | <WRITABLESTREAM[]> | <TRANSFORMSTREAM[]>
SOURCE <STREAM> | <ITERABLE> | <ASYNCITERABLE> | <FUNCTION> | <READABLESTREAM>
RETURNS: <ITERABLE> | <ASYNCITERABLE>
...TRANSFORMS <STREAM> | <FUNCTION> | <TRANSFORMSTREAM>
SOURCE <ASYNCITERABLE>
RETURNS: <ASYNCITERABLE>
DESTINATION <STREAM> | <FUNCTION> | <WRITABLESTREAM>
SOURCE <ASYNCITERABLE>
RETURNS: <ASYNCITERABLE> | <PROMISE>
CALLBACK <FUNCTION> CALLED WHEN THE PIPELINE IS FULLY DONE.
ERR <ERROR>
VAL RESOLVED VALUE OF PROMISE RETURNED BY DESTINATION.
RETURNS: <STREAM>
A MODULE METHOD TO PIPE BETWEEN STREAMS AND GENERATORS FORWARDING ERRORS AND PROPERLY CLEANING UP AND PROVIDE A CALLBACK WHEN THE PIPELINE IS COMPLETE.

CONST { PIPELINE } = REQUIRE('NODE:STREAM');
CONST FS = REQUIRE('NODE:FS');
CONST ZLIB = REQUIRE('NODE:ZLIB');

// USE THE PIPELINE API TO EASILY PIPE A SERIES OF STREAMS
// TOGETHER AND GET NOTIFIED WHEN THE PIPELINE IS FULLY DONE.

// A PIPELINE TO GZIP A POTENTIALLY HUGE TAR FILE EFFICIENTLY:

PIPELINE(
  FS.CREATEREADSTREAM('ARCHIVE.TAR'),
  ZLIB.CREATEGZIP(),
  FS.CREATEWRITESTREAM('ARCHIVE.TAR.GZ'),
  (ERR) => {
    IF (ERR) {
      CONSOLE.ERROR('PIPELINE FAILED.', ERR);
    } ELSE {
      CONSOLE.LOG('PIPELINE SUCCEEDED.');
    }
  },
); COPY
THE PIPELINE API PROVIDES A PROMISE VERSION.

STREAM.PIPELINE() WILL CALL STREAM.DESTROY(ERR) ON ALL STREAMS EXCEPT:

READABLE STREAMS WHICH HAVE EMITTED 'END' OR 'CLOSE'.
WRITABLE STREAMS WHICH HAVE EMITTED 'FINISH' OR 'CLOSE'.
STREAM.PIPELINE() LEAVES DANGLING EVENT LISTENERS ON THE STREAMS AFTER THE CALLBACK HAS BEEN INVOKED. IN THE CASE OF REUSE OF STREAMS AFTER FAILURE, THIS CAN CAUSE EVENT LISTENER LEAKS AND SWALLOWED ERRORS. IF THE LAST STREAM IS READABLE, DANGLING EVENT LISTENERS WILL BE REMOVED SO THAT THE LAST STREAM CAN BE CONSUMED LATER.

STREAM.PIPELINE() CLOSES ALL THE STREAMS WHEN AN ERROR IS RAISED. THE INCOMINGREQUEST USAGE WITH PIPELINE COULD LEAD TO AN UNEXPECTED BEHAVIOR ONCE IT WOULD DESTROY THE SOCKET WITHOUT SENDING THE EXPECTED RESPONSE. SEE THE EXAMPLE BELOW:

CONST FS = REQUIRE('NODE:FS');
CONST HTTP = REQUIRE('NODE:HTTP');
CONST { PIPELINE } = REQUIRE('NODE:STREAM');

CONST SERVER = HTTP.CREATESERVER((REQ, RES) => {
  CONST FILESTREAM = FS.CREATEREADSTREAM('./FILENOTEXIST.TXT');
  PIPELINE(FILESTREAM, RES, (ERR) => {
    IF (ERR) {
      CONSOLE.LOG(ERR); // NO SUCH FILE
      // THIS MESSAGE CAN'T BE SENT ONCE `PIPELINE` ALREADY DESTROYED THE SOCKET
      RETURN RES.END('ERROR!!!');
    }
  });
}); COPY
STREAM.COMPOSE(...STREAMS)#
HISTORY
STABILITY: 1 - STREAM.COMPOSE IS EXPERIMENTAL.
STREAMS <STREAM[]> | <ITERABLE[]> | <ASYNCITERABLE[]> | <FUNCTION[]> | <READABLESTREAM[]> | <WRITABLESTREAM[]> | <TRANSFORMSTREAM[]>
RETURNS: <STREAM.DUPLEX>
COMBINES TWO OR MORE STREAMS INTO A DUPLEX STREAM THAT WRITES TO THE FIRST STREAM AND READS FROM THE LAST. EACH PROVIDED STREAM IS PIPED INTO THE NEXT, USING STREAM.PIPELINE. IF ANY OF THE STREAMS ERROR THEN ALL ARE DESTROYED, INCLUDING THE OUTER DUPLEX STREAM.

BECAUSE STREAM.COMPOSE RETURNS A NEW STREAM THAT IN TURN CAN (AND SHOULD) BE PIPED INTO OTHER STREAMS, IT ENABLES COMPOSITION. IN CONTRAST, WHEN PASSING STREAMS TO STREAM.PIPELINE, TYPICALLY THE FIRST STREAM IS A READABLE STREAM AND THE LAST A WRITABLE STREAM, FORMING A CLOSED CIRCUIT.

IF PASSED A FUNCTION IT MUST BE A FACTORY METHOD TAKING A SOURCE ITERABLE.

IMPORT { COMPOSE, TRANSFORM } FROM 'NODE:STREAM';

CONST REMOVESPACES = NEW TRANSFORM({
  TRANSFORM(CHUNK, ENCODING, CALLBACK) {
    CALLBACK(NULL, STRING(CHUNK).REPLACE(' ', ''));
  },
});

ASYNC FUNCTION* TOUPPER(SOURCE) {
  FOR AWAIT (CONST CHUNK OF SOURCE) {
    YIELD STRING(CHUNK).TOUPPERCASE();
  }
}

LET RES = '';
FOR AWAIT (CONST BUF OF COMPOSE(REMOVESPACES, TOUPPER).END('HELLO WORLD')) {
  RES += BUF;
}

CONSOLE.LOG(RES); // PRINTS 'HELLOWORLD' COPY
STREAM.COMPOSE CAN BE USED TO CONVERT ASYNC ITERABLES, GENERATORS AND FUNCTIONS INTO STREAMS.

ASYNCITERABLE CONVERTS INTO A READABLE DUPLEX. CANNOT YIELD NULL.
ASYNCGENERATORFUNCTION CONVERTS INTO A READABLE/WRITABLE TRANSFORM DUPLEX. MUST TAKE A SOURCE ASYNCITERABLE AS FIRST PARAMETER. CANNOT YIELD NULL.
ASYNCFUNCTION CONVERTS INTO A WRITABLE DUPLEX. MUST RETURN EITHER NULL OR UNDEFINED.
IMPORT { COMPOSE } FROM 'NODE:STREAM';
IMPORT { FINISHED } FROM 'NODE:STREAM/PROMISES';

// CONVERT ASYNCITERABLE INTO READABLE DUPLEX.
CONST S1 = COMPOSE(ASYNC FUNCTION*() {
  YIELD 'HELLO';
  YIELD 'WORLD';
}());

// CONVERT ASYNCGENERATOR INTO TRANSFORM DUPLEX.
CONST S2 = COMPOSE(ASYNC FUNCTION*(SOURCE) {
  FOR AWAIT (CONST CHUNK OF SOURCE) {
    YIELD STRING(CHUNK).TOUPPERCASE();
  }
});

LET RES = '';

// CONVERT ASYNCFUNCTION INTO WRITABLE DUPLEX.
CONST S3 = COMPOSE(ASYNC FUNCTION(SOURCE) {
  FOR AWAIT (CONST CHUNK OF SOURCE) {
    RES += CHUNK;
  }
});

AWAIT FINISHED(COMPOSE(S1, S2, S3));

CONSOLE.LOG(RES); // PRINTS 'HELLOWORLD' COPY
SEE READABLE.COMPOSE(STREAM) FOR STREAM.COMPOSE AS OPERATOR.

STREAM.READABLE.FROM(ITERABLE[, OPTIONS])#
ADDED IN: V12.3.0, V10.17.0
ITERABLE <ITERABLE> OBJECT IMPLEMENTING THE SYMBOL.ASYNCITERATOR OR SYMBOL.ITERATOR ITERABLE PROTOCOL. EMITS AN 'ERROR' EVENT IF A NULL VALUE IS PASSED.
OPTIONS <OBJECT> OPTIONS PROVIDED TO NEW STREAM.READABLE([OPTIONS]). BY DEFAULT, READABLE.FROM() WILL SET OPTIONS.OBJECTMODE TO TRUE, UNLESS THIS IS EXPLICITLY OPTED OUT BY SETTING OPTIONS.OBJECTMODE TO FALSE.
RETURNS: <STREAM.READABLE>
A UTILITY METHOD FOR CREATING READABLE STREAMS OUT OF ITERATORS.

CONST { READABLE } = REQUIRE('NODE:STREAM');

ASYNC FUNCTION * GENERATE() {
  YIELD 'HELLO';
  YIELD 'STREAMS';
}

CONST READABLE = READABLE.FROM(GENERATE());

READABLE.ON('DATA', (CHUNK) => {
  CONSOLE.LOG(CHUNK);
}); COPY
CALLING READABLE.FROM(STRING) OR READABLE.FROM(BUFFER) WILL NOT HAVE THE STRINGS OR BUFFERS BE ITERATED TO MATCH THE OTHER STREAMS SEMANTICS FOR PERFORMANCE REASONS.

IF AN ITERABLE OBJECT CONTAINING PROMISES IS PASSED AS AN ARGUMENT, IT MIGHT RESULT IN UNHANDLED REJECTION.

CONST { READABLE } = REQUIRE('NODE:STREAM');

READABLE.FROM([
  NEW PROMISE((RESOLVE) => SETTIMEOUT(RESOLVE('1'), 1500)),
  NEW PROMISE((_, REJECT) => SETTIMEOUT(REJECT(NEW ERROR('2')), 1000)), // UNHANDLED REJECTION
]); COPY
STREAM.READABLE.FROMWEB(READABLESTREAM[, OPTIONS])#
ADDED IN: V17.0.0
STABILITY: 1 - EXPERIMENTAL
READABLESTREAM <READABLESTREAM>
OPTIONS <OBJECT>
ENCODING <STRING>
HIGHWATERMARK <NUMBER>
OBJECTMODE <BOOLEAN>
SIGNAL <ABORTSIGNAL>
RETURNS: <STREAM.READABLE>
STREAM.READABLE.ISDISTURBED(STREAM)#
ADDED IN: V16.8.0
STABILITY: 1 - EXPERIMENTAL
STREAM <STREAM.READABLE> | <READABLESTREAM>
RETURNS: BOOLEAN
RETURNS WHETHER THE STREAM HAS BEEN READ FROM OR CANCELLED.

STREAM.ISERRORED(STREAM)#
ADDED IN: V17.3.0, V16.14.0
STABILITY: 1 - EXPERIMENTAL
STREAM <READABLE> | <WRITABLE> | <DUPLEX> | <WRITABLESTREAM> | <READABLESTREAM>
RETURNS: <BOOLEAN>
RETURNS WHETHER THE STREAM HAS ENCOUNTERED AN ERROR.

STREAM.ISREADABLE(STREAM)#
ADDED IN: V17.4.0, V16.14.0
STABILITY: 1 - EXPERIMENTAL
STREAM <READABLE> | <DUPLEX> | <READABLESTREAM>
RETURNS: <BOOLEAN>
RETURNS WHETHER THE STREAM IS READABLE.

STREAM.READABLE.TOWEB(STREAMREADABLE[, OPTIONS])#
ADDED IN: V17.0.0
STABILITY: 1 - EXPERIMENTAL
STREAMREADABLE <STREAM.READABLE>
OPTIONS <OBJECT>
STRATEGY <OBJECT>
HIGHWATERMARK <NUMBER> THE MAXIMUM INTERNAL QUEUE SIZE (OF THE CREATED READABLESTREAM) BEFORE BACKPRESSURE IS APPLIED IN READING FROM THE GIVEN STREAM.READABLE. IF NO VALUE IS PROVIDED, IT WILL BE TAKEN FROM THE GIVEN STREAM.READABLE.
SIZE <FUNCTION> A FUNCTION THAT SIZE OF THE GIVEN CHUNK OF DATA. IF NO VALUE IS PROVIDED, THE SIZE WILL BE 1 FOR ALL THE CHUNKS.
CHUNK <ANY>
RETURNS: <NUMBER>
RETURNS: <READABLESTREAM>
STREAM.WRITABLE.FROMWEB(WRITABLESTREAM[, OPTIONS])#
ADDED IN: V17.0.0
STABILITY: 1 - EXPERIMENTAL
WRITABLESTREAM <WRITABLESTREAM>
OPTIONS <OBJECT>
DECODESTRINGS <BOOLEAN>
HIGHWATERMARK <NUMBER>
OBJECTMODE <BOOLEAN>
SIGNAL <ABORTSIGNAL>
RETURNS: <STREAM.WRITABLE>
STREAM.WRITABLE.TOWEB(STREAMWRITABLE)#
ADDED IN: V17.0.0
STABILITY: 1 - EXPERIMENTAL
STREAMWRITABLE <STREAM.WRITABLE>
RETURNS: <WRITABLESTREAM>
STREAM.DUPLEX.FROM(SRC)#
HISTORY
SRC <STREAM> | <BLOB> | <ARRAYBUFFER> | <STRING> | <ITERABLE> | <ASYNCITERABLE> | <ASYNCGENERATORFUNCTION> | <ASYNCFUNCTION> | <PROMISE> | <OBJECT> | <READABLESTREAM> | <WRITABLESTREAM>
A UTILITY METHOD FOR CREATING DUPLEX STREAMS.

STREAM CONVERTS WRITABLE STREAM INTO WRITABLE DUPLEX AND READABLE STREAM TO DUPLEX.
BLOB CONVERTS INTO READABLE DUPLEX.
STRING CONVERTS INTO READABLE DUPLEX.
ARRAYBUFFER CONVERTS INTO READABLE DUPLEX.
ASYNCITERABLE CONVERTS INTO A READABLE DUPLEX. CANNOT YIELD NULL.
ASYNCGENERATORFUNCTION CONVERTS INTO A READABLE/WRITABLE TRANSFORM DUPLEX. MUST TAKE A SOURCE ASYNCITERABLE AS FIRST PARAMETER. CANNOT YIELD NULL.
ASYNCFUNCTION CONVERTS INTO A WRITABLE DUPLEX. MUST RETURN EITHER NULL OR UNDEFINED
OBJECT ({ WRITABLE, READABLE }) CONVERTS READABLE AND WRITABLE INTO STREAM AND THEN COMBINES THEM INTO DUPLEX WHERE THE DUPLEX WILL WRITE TO THE WRITABLE AND READ FROM THE READABLE.
PROMISE CONVERTS INTO READABLE DUPLEX. VALUE NULL IS IGNORED.
READABLESTREAM CONVERTS INTO READABLE DUPLEX.
WRITABLESTREAM CONVERTS INTO WRITABLE DUPLEX.
RETURNS: <STREAM.DUPLEX>
IF AN ITERABLE OBJECT CONTAINING PROMISES IS PASSED AS AN ARGUMENT, IT MIGHT RESULT IN UNHANDLED REJECTION.

CONST { DUPLEX } = REQUIRE('NODE:STREAM');

DUPLEX.FROM([
  NEW PROMISE((RESOLVE) => SETTIMEOUT(RESOLVE('1'), 1500)),
  NEW PROMISE((_, REJECT) => SETTIMEOUT(REJECT(NEW ERROR('2')), 1000)), // UNHANDLED REJECTION
]); COPY
STREAM.DUPLEX.FROMWEB(PAIR[, OPTIONS])#
ADDED IN: V17.0.0
STABILITY: 1 - EXPERIMENTAL
PAIR <OBJECT>
READABLE <READABLESTREAM>
WRITABLE <WRITABLESTREAM>
OPTIONS <OBJECT>
ALLOWHALFOPEN <BOOLEAN>
DECODESTRINGS <BOOLEAN>
ENCODING <STRING>
HIGHWATERMARK <NUMBER>
OBJECTMODE <BOOLEAN>
SIGNAL <ABORTSIGNAL>
RETURNS: <STREAM.DUPLEX>
IMPORT { DUPLEX } FROM 'NODE:STREAM';
IMPORT {
  READABLESTREAM,
  WRITABLESTREAM,
} FROM 'NODE:STREAM/WEB';

CONST READABLE = NEW READABLESTREAM({
  START(CONTROLLER) {
    CONTROLLER.ENQUEUE('WORLD');
  },
});

CONST WRITABLE = NEW WRITABLESTREAM({
  WRITE(CHUNK) {
    CONSOLE.LOG('WRITABLE', CHUNK);
  },
});

CONST PAIR = {
  READABLE,
  WRITABLE,
};
CONST DUPLEX = DUPLEX.FROMWEB(PAIR, { ENCODING: 'UTF8', OBJECTMODE: TRUE });

DUPLEX.WRITE('HELLO');

FOR AWAIT (CONST CHUNK OF DUPLEX) {
  CONSOLE.LOG('READABLE', CHUNK);
}COPY
STREAM.DUPLEX.TOWEB(STREAMDUPLEX)#
ADDED IN: V17.0.0
STABILITY: 1 - EXPERIMENTAL
STREAMDUPLEX <STREAM.DUPLEX>
RETURNS: <OBJECT>
READABLE <READABLESTREAM>
WRITABLE <WRITABLESTREAM>
IMPORT { DUPLEX } FROM 'NODE:STREAM';

CONST DUPLEX = DUPLEX({
  OBJECTMODE: TRUE,
  READ() {
    THIS.PUSH('WORLD');
    THIS.PUSH(NULL);
  },
  WRITE(CHUNK, ENCODING, CALLBACK) {
    CONSOLE.LOG('WRITABLE', CHUNK);
    CALLBACK();
  },
});

CONST { READABLE, WRITABLE } = DUPLEX.TOWEB(DUPLEX);
WRITABLE.GETWRITER().WRITE('HELLO');

CONST { VALUE } = AWAIT READABLE.GETREADER().READ();
CONSOLE.LOG('READABLE', VALUE);COPY
STREAM.ADDABORTSIGNAL(SIGNAL, STREAM)#
HISTORY
SIGNAL <ABORTSIGNAL> A SIGNAL REPRESENTING POSSIBLE CANCELLATION
STREAM <STREAM> | <READABLESTREAM> | <WRITABLESTREAM>
A STREAM TO ATTACH A SIGNAL TO.

ATTACHES AN ABORTSIGNAL TO A READABLE OR WRITEABLE STREAM. THIS LETS CODE CONTROL STREAM DESTRUCTION USING AN ABORTCONTROLLER.

CALLING ABORT ON THE ABORTCONTROLLER CORRESPONDING TO THE PASSED ABORTSIGNAL WILL BEHAVE THE SAME WAY AS CALLING .DESTROY(NEW ABORTERROR()) ON THE STREAM, AND CONTROLLER.ERROR(NEW ABORTERROR()) FOR WEBSTREAMS.

CONST FS = REQUIRE('NODE:FS');

CONST CONTROLLER = NEW ABORTCONTROLLER();
CONST READ = ADDABORTSIGNAL(
  CONTROLLER.SIGNAL,
  FS.CREATEREADSTREAM(('OBJECT.JSON')),
);
// LATER, ABORT THE OPERATION CLOSING THE STREAM
CONTROLLER.ABORT(); COPY
OR USING AN ABORTSIGNAL WITH A READABLE STREAM AS AN ASYNC ITERABLE:

CONST CONTROLLER = NEW ABORTCONTROLLER();
SETTIMEOUT(() => CONTROLLER.ABORT(), 10_000); // SET A TIMEOUT
CONST STREAM = ADDABORTSIGNAL(
  CONTROLLER.SIGNAL,
  FS.CREATEREADSTREAM(('OBJECT.JSON')),
);
(ASYNC () => {
  TRY {
    FOR AWAIT (CONST CHUNK OF STREAM) {
      AWAIT PROCESS(CHUNK);
    }
  } CATCH (E) {
    IF (E.NAME === 'ABORTERROR') {
      // THE OPERATION WAS CANCELLED
    } ELSE {
      THROW E;
    }
  }
})(); COPY
OR USING AN ABORTSIGNAL WITH A READABLESTREAM:

CONST CONTROLLER = NEW ABORTCONTROLLER();
CONST RS = NEW READABLESTREAM({
  START(CONTROLLER) {
    CONTROLLER.ENQUEUE('HELLO');
    CONTROLLER.ENQUEUE('WORLD');
    CONTROLLER.CLOSE();
  },
});

ADDABORTSIGNAL(CONTROLLER.SIGNAL, RS);

FINISHED(RS, (ERR) => {
  IF (ERR) {
    IF (ERR.NAME === 'ABORTERROR') {
      // THE OPERATION WAS CANCELLED
    }
  }
});

CONST READER = RS.GETREADER();

READER.READ().THEN(({ VALUE, DONE }) => {
  CONSOLE.LOG(VALUE); // HELLO
  CONSOLE.LOG(DONE); // FALSE
  CONTROLLER.ABORT();
}); COPY
STREAM.GETDEFAULTHIGHWATERMARK(OBJECTMODE)#
ADDED IN: V19.9.0
<BOOLEAN> OBJECTMODE
RETURNS: <INTEGER>
RETURNS THE DEFAULT HIGHWATERMARK USED BY STREAMS. DEFAULTS TO 16384 (16 KIB), OR 16 FOR OBJECTMODE.

STREAM.SETDEFAULTHIGHWATERMARK(OBJECTMODE, VALUE)#
ADDED IN: V19.9.0
<BOOLEAN> OBJECTMODE
<INTEGER> HIGHWATERMARK VALUE
SETS THE DEFAULT HIGHWATERMARK USED BY STREAMS.

API FOR STREAM IMPLEMENTERS#
THE NODE:STREAM MODULE API HAS BEEN DESIGNED TO MAKE IT POSSIBLE TO EASILY IMPLEMENT STREAMS USING JAVASCRIPT'S PROTOTYPAL INHERITANCE MODEL.

FIRST, A STREAM DEVELOPER WOULD DECLARE A NEW JAVASCRIPT CLASS THAT EXTENDS ONE OF THE FOUR BASIC STREAM CLASSES (STREAM.WRITABLE, STREAM.READABLE, STREAM.DUPLEX, OR STREAM.TRANSFORM), MAKING SURE THEY CALL THE APPROPRIATE PARENT CLASS CONSTRUCTOR:

CONST { WRITABLE } = REQUIRE('NODE:STREAM');

CLASS MYWRITABLE EXTENDS WRITABLE {
  CONSTRUCTOR({ HIGHWATERMARK, ...OPTIONS }) {
    SUPER({ HIGHWATERMARK });
    // ...
  }
} COPY
WHEN EXTENDING STREAMS, KEEP IN MIND WHAT OPTIONS THE USER CAN AND SHOULD PROVIDE BEFORE FORWARDING THESE TO THE BASE CONSTRUCTOR. FOR EXAMPLE, IF THE IMPLEMENTATION MAKES ASSUMPTIONS IN REGARD TO THE AUTODESTROY AND EMITCLOSE OPTIONS, DO NOT ALLOW THE USER TO OVERRIDE THESE. BE EXPLICIT ABOUT WHAT OPTIONS ARE FORWARDED INSTEAD OF IMPLICITLY FORWARDING ALL OPTIONS.

THE NEW STREAM CLASS MUST THEN IMPLEMENT ONE OR MORE SPECIFIC METHODS, DEPENDING ON THE TYPE OF STREAM BEING CREATED, AS DETAILED IN THE CHART BELOW:

USE-CASE	CLASS	METHOD(S) TO IMPLEMENT
READING ONLY	READABLE	_READ()
WRITING ONLY	WRITABLE	_WRITE(), _WRITEV(), _FINAL()
READING AND WRITING	DUPLEX	_READ(), _WRITE(), _WRITEV(), _FINAL()
OPERATE ON WRITTEN DATA, THEN READ THE RESULT	TRANSFORM	_TRANSFORM(), _FLUSH(), _FINAL()
THE IMPLEMENTATION CODE FOR A STREAM SHOULD NEVER CALL THE "PUBLIC" METHODS OF A STREAM THAT ARE INTENDED FOR USE BY CONSUMERS (AS DESCRIBED IN THE API FOR STREAM CONSUMERS SECTION). DOING SO MAY LEAD TO ADVERSE SIDE EFFECTS IN APPLICATION CODE CONSUMING THE STREAM.

AVOID OVERRIDING PUBLIC METHODS SUCH AS WRITE(), END(), CORK(), UNCORK(), READ() AND DESTROY(), OR EMITTING INTERNAL EVENTS SUCH AS 'ERROR', 'DATA', 'END', 'FINISH' AND 'CLOSE' THROUGH .EMIT(). DOING SO CAN BREAK CURRENT AND FUTURE STREAM INVARIANTS LEADING TO BEHAVIOR AND/OR COMPATIBILITY ISSUES WITH OTHER STREAMS, STREAM UTILITIES, AND USER EXPECTATIONS.

SIMPLIFIED CONSTRUCTION#
ADDED IN: V1.2.0
FOR MANY SIMPLE CASES, IT IS POSSIBLE TO CREATE A STREAM WITHOUT RELYING ON INHERITANCE. THIS CAN BE ACCOMPLISHED BY DIRECTLY CREATING INSTANCES OF THE STREAM.WRITABLE, STREAM.READABLE, STREAM.DUPLEX, OR STREAM.TRANSFORM OBJECTS AND PASSING APPROPRIATE METHODS AS CONSTRUCTOR OPTIONS.

CONST { WRITABLE } = REQUIRE('NODE:STREAM');

CONST MYWRITABLE = NEW WRITABLE({
  CONSTRUCT(CALLBACK) {
    // INITIALIZE STATE AND LOAD RESOURCES...
  },
  WRITE(CHUNK, ENCODING, CALLBACK) {
    // ...
  },
  DESTROY() {
    // FREE RESOURCES...
  },
}); COPY
IMPLEMENTING A WRITABLE STREAM#
THE STREAM.WRITABLE CLASS IS EXTENDED TO IMPLEMENT A WRITABLE STREAM.

CUSTOM WRITABLE STREAMS MUST CALL THE NEW STREAM.WRITABLE([OPTIONS]) CONSTRUCTOR AND IMPLEMENT THE WRITABLE._WRITE() AND/OR WRITABLE._WRITEV() METHOD.

NEW STREAM.WRITABLE([OPTIONS])#
HISTORY
OPTIONS <OBJECT>
HIGHWATERMARK <NUMBER> BUFFER LEVEL WHEN STREAM.WRITE() STARTS RETURNING FALSE. DEFAULT: 16384 (16 KIB), OR 16 FOR OBJECTMODE STREAMS.
DECODESTRINGS <BOOLEAN> WHETHER TO ENCODE STRINGS PASSED TO STREAM.WRITE() TO BUFFERS (WITH THE ENCODING SPECIFIED IN THE STREAM.WRITE() CALL) BEFORE PASSING THEM TO STREAM._WRITE(). OTHER TYPES OF DATA ARE NOT CONVERTED (I.E. BUFFERS ARE NOT DECODED INTO STRINGS). SETTING TO FALSE WILL PREVENT STRINGS FROM BEING CONVERTED. DEFAULT: TRUE.
DEFAULTENCODING <STRING> THE DEFAULT ENCODING THAT IS USED WHEN NO ENCODING IS SPECIFIED AS AN ARGUMENT TO STREAM.WRITE(). DEFAULT: 'UTF8'.
OBJECTMODE <BOOLEAN> WHETHER OR NOT THE STREAM.WRITE(ANYOBJ) IS A VALID OPERATION. WHEN SET, IT BECOMES POSSIBLE TO WRITE JAVASCRIPT VALUES OTHER THAN STRING, BUFFER OR UINT8ARRAY IF SUPPORTED BY THE STREAM IMPLEMENTATION. DEFAULT: FALSE.
EMITCLOSE <BOOLEAN> WHETHER OR NOT THE STREAM SHOULD EMIT 'CLOSE' AFTER IT HAS BEEN DESTROYED. DEFAULT: TRUE.
WRITE <FUNCTION> IMPLEMENTATION FOR THE STREAM._WRITE() METHOD.
WRITEV <FUNCTION> IMPLEMENTATION FOR THE STREAM._WRITEV() METHOD.
DESTROY <FUNCTION> IMPLEMENTATION FOR THE STREAM._DESTROY() METHOD.
FINAL <FUNCTION> IMPLEMENTATION FOR THE STREAM._FINAL() METHOD.
CONSTRUCT <FUNCTION> IMPLEMENTATION FOR THE STREAM._CONSTRUCT() METHOD.
AUTODESTROY <BOOLEAN> WHETHER THIS STREAM SHOULD AUTOMATICALLY CALL .DESTROY() ON ITSELF AFTER ENDING. DEFAULT: TRUE.
SIGNAL <ABORTSIGNAL> A SIGNAL REPRESENTING POSSIBLE CANCELLATION.
CONST { WRITABLE } = REQUIRE('NODE:STREAM');

CLASS MYWRITABLE EXTENDS WRITABLE {
  CONSTRUCTOR(OPTIONS) {
    // CALLS THE STREAM.WRITABLE() CONSTRUCTOR.
    SUPER(OPTIONS);
    // ...
  }
} COPY
OR, WHEN USING PRE-ES6 STYLE CONSTRUCTORS:

CONST { WRITABLE } = REQUIRE('NODE:STREAM');
CONST UTIL = REQUIRE('NODE:UTIL');

FUNCTION MYWRITABLE(OPTIONS) {
  IF (!(THIS INSTANCEOF MYWRITABLE))
    RETURN NEW MYWRITABLE(OPTIONS);
  WRITABLE.CALL(THIS, OPTIONS);
}
UTIL.INHERITS(MYWRITABLE, WRITABLE); COPY
OR, USING THE SIMPLIFIED CONSTRUCTOR APPROACH:

CONST { WRITABLE } = REQUIRE('NODE:STREAM');

CONST MYWRITABLE = NEW WRITABLE({
  WRITE(CHUNK, ENCODING, CALLBACK) {
    // ...
  },
  WRITEV(CHUNKS, CALLBACK) {
    // ...
  },
}); COPY
CALLING ABORT ON THE ABORTCONTROLLER CORRESPONDING TO THE PASSED ABORTSIGNAL WILL BEHAVE THE SAME WAY AS CALLING .DESTROY(NEW ABORTERROR()) ON THE WRITEABLE STREAM.

CONST { WRITABLE } = REQUIRE('NODE:STREAM');

CONST CONTROLLER = NEW ABORTCONTROLLER();
CONST MYWRITABLE = NEW WRITABLE({
  WRITE(CHUNK, ENCODING, CALLBACK) {
    // ...
  },
  WRITEV(CHUNKS, CALLBACK) {
    // ...
  },
  SIGNAL: CONTROLLER.SIGNAL,
});
// LATER, ABORT THE OPERATION CLOSING THE STREAM
CONTROLLER.ABORT(); COPY
WRITABLE._CONSTRUCT(CALLBACK)#
ADDED IN: V15.0.0
CALLBACK <FUNCTION> CALL THIS FUNCTION (OPTIONALLY WITH AN ERROR ARGUMENT) WHEN THE STREAM HAS FINISHED INITIALIZING.
THE _CONSTRUCT() METHOD MUST NOT BE CALLED DIRECTLY. IT MAY BE IMPLEMENTED BY CHILD CLASSES, AND IF SO, WILL BE CALLED BY THE INTERNAL WRITABLE CLASS METHODS ONLY.

THIS OPTIONAL FUNCTION WILL BE CALLED IN A TICK AFTER THE STREAM CONSTRUCTOR HAS RETURNED, DELAYING ANY _WRITE(), _FINAL() AND _DESTROY() CALLS UNTIL CALLBACK IS CALLED. THIS IS USEFUL TO INITIALIZE STATE OR ASYNCHRONOUSLY INITIALIZE RESOURCES BEFORE THE STREAM CAN BE USED.

CONST { WRITABLE } = REQUIRE('NODE:STREAM');
CONST FS = REQUIRE('NODE:FS');

CLASS WRITESTREAM EXTENDS WRITABLE {
  CONSTRUCTOR(FILENAME) {
    SUPER();
    THIS.FILENAME = FILENAME;
    THIS.FD = NULL;
  }
  _CONSTRUCT(CALLBACK) {
    FS.OPEN(THIS.FILENAME, (ERR, FD) => {
      IF (ERR) {
        CALLBACK(ERR);
      } ELSE {
        THIS.FD = FD;
        CALLBACK();
      }
    });
  }
  _WRITE(CHUNK, ENCODING, CALLBACK) {
    FS.WRITE(THIS.FD, CHUNK, CALLBACK);
  }
  _DESTROY(ERR, CALLBACK) {
    IF (THIS.FD) {
      FS.CLOSE(THIS.FD, (ER) => CALLBACK(ER || ERR));
    } ELSE {
      CALLBACK(ERR);
    }
  }
} COPY
WRITABLE._WRITE(CHUNK, ENCODING, CALLBACK)#
HISTORY
CHUNK <BUFFER> | <STRING> | <ANY> THE BUFFER TO BE WRITTEN, CONVERTED FROM THE STRING PASSED TO STREAM.WRITE(). IF THE STREAM'S DECODESTRINGS OPTION IS FALSE OR THE STREAM IS OPERATING IN OBJECT MODE, THE CHUNK WILL NOT BE CONVERTED & WILL BE WHATEVER WAS PASSED TO STREAM.WRITE().
ENCODING <STRING> IF THE CHUNK IS A STRING, THEN ENCODING IS THE CHARACTER ENCODING OF THAT STRING. IF CHUNK IS A BUFFER, OR IF THE STREAM IS OPERATING IN OBJECT MODE, ENCODING MAY BE IGNORED.
CALLBACK <FUNCTION> CALL THIS FUNCTION (OPTIONALLY WITH AN ERROR ARGUMENT) WHEN PROCESSING IS COMPLETE FOR THE SUPPLIED CHUNK.
ALL WRITABLE STREAM IMPLEMENTATIONS MUST PROVIDE A WRITABLE._WRITE() AND/OR WRITABLE._WRITEV() METHOD TO SEND DATA TO THE UNDERLYING RESOURCE.

TRANSFORM STREAMS PROVIDE THEIR OWN IMPLEMENTATION OF THE WRITABLE._WRITE().

THIS FUNCTION MUST NOT BE CALLED BY APPLICATION CODE DIRECTLY. IT SHOULD BE IMPLEMENTED BY CHILD CLASSES, AND CALLED BY THE INTERNAL WRITABLE CLASS METHODS ONLY.

THE CALLBACK FUNCTION MUST BE CALLED SYNCHRONOUSLY INSIDE OF WRITABLE._WRITE() OR ASYNCHRONOUSLY (I.E. DIFFERENT TICK) TO SIGNAL EITHER THAT THE WRITE COMPLETED SUCCESSFULLY OR FAILED WITH AN ERROR. THE FIRST ARGUMENT PASSED TO THE CALLBACK MUST BE THE ERROR OBJECT IF THE CALL FAILED OR NULL IF THE WRITE SUCCEEDED.

ALL CALLS TO WRITABLE.WRITE() THAT OCCUR BETWEEN THE TIME WRITABLE._WRITE() IS CALLED AND THE CALLBACK IS CALLED WILL CAUSE THE WRITTEN DATA TO BE BUFFERED. WHEN THE CALLBACK IS INVOKED, THE STREAM MIGHT EMIT A 'DRAIN' EVENT. IF A STREAM IMPLEMENTATION IS CAPABLE OF PROCESSING MULTIPLE CHUNKS OF DATA AT ONCE, THE WRITABLE._WRITEV() METHOD SHOULD BE IMPLEMENTED.

IF THE DECODESTRINGS PROPERTY IS EXPLICITLY SET TO FALSE IN THE CONSTRUCTOR OPTIONS, THEN CHUNK WILL REMAIN THE SAME OBJECT THAT IS PASSED TO .WRITE(), AND MAY BE A STRING RATHER THAN A BUFFER. THIS IS TO SUPPORT IMPLEMENTATIONS THAT HAVE AN OPTIMIZED HANDLING FOR CERTAIN STRING DATA ENCODINGS. IN THAT CASE, THE ENCODING ARGUMENT WILL INDICATE THE CHARACTER ENCODING OF THE STRING. OTHERWISE, THE ENCODING ARGUMENT CAN BE SAFELY IGNORED.

THE WRITABLE._WRITE() METHOD IS PREFIXED WITH AN UNDERSCORE BECAUSE IT IS INTERNAL TO THE CLASS THAT DEFINES IT, AND SHOULD NEVER BE CALLED DIRECTLY BY USER PROGRAMS.

WRITABLE._WRITEV(CHUNKS, CALLBACK)#
CHUNKS <OBJECT[]> THE DATA TO BE WRITTEN. THE VALUE IS AN ARRAY OF <OBJECT> THAT EACH REPRESENT A DISCRETE CHUNK OF DATA TO WRITE. THE PROPERTIES OF THESE OBJECTS ARE:
CHUNK <BUFFER> | <STRING> A BUFFER INSTANCE OR STRING CONTAINING THE DATA TO BE WRITTEN. THE CHUNK WILL BE A STRING IF THE WRITABLE WAS CREATED WITH THE DECODESTRINGS OPTION SET TO FALSE AND A STRING WAS PASSED TO WRITE().
ENCODING <STRING> THE CHARACTER ENCODING OF THE CHUNK. IF CHUNK IS A BUFFER, THE ENCODING WILL BE 'BUFFER'.
CALLBACK <FUNCTION> A CALLBACK FUNCTION (OPTIONALLY WITH AN ERROR ARGUMENT) TO BE INVOKED WHEN PROCESSING IS COMPLETE FOR THE SUPPLIED CHUNKS.
THIS FUNCTION MUST NOT BE CALLED BY APPLICATION CODE DIRECTLY. IT SHOULD BE IMPLEMENTED BY CHILD CLASSES, AND CALLED BY THE INTERNAL WRITABLE CLASS METHODS ONLY.

THE WRITABLE._WRITEV() METHOD MAY BE IMPLEMENTED IN ADDITION OR ALTERNATIVELY TO WRITABLE._WRITE() IN STREAM IMPLEMENTATIONS THAT ARE CAPABLE OF PROCESSING MULTIPLE CHUNKS OF DATA AT ONCE. IF IMPLEMENTED AND IF THERE IS BUFFERED DATA FROM PREVIOUS WRITES, _WRITEV() WILL BE CALLED INSTEAD OF _WRITE().

THE WRITABLE._WRITEV() METHOD IS PREFIXED WITH AN UNDERSCORE BECAUSE IT IS INTERNAL TO THE CLASS THAT DEFINES IT, AND SHOULD NEVER BE CALLED DIRECTLY BY USER PROGRAMS.

WRITABLE._DESTROY(ERR, CALLBACK)#
ADDED IN: V8.0.0
ERR <ERROR> A POSSIBLE ERROR.
CALLBACK <FUNCTION> A CALLBACK FUNCTION THAT TAKES AN OPTIONAL ERROR ARGUMENT.
THE _DESTROY() METHOD IS CALLED BY WRITABLE.DESTROY(). IT CAN BE OVERRIDDEN BY CHILD CLASSES BUT IT MUST NOT BE CALLED DIRECTLY. FURTHERMORE, THE CALLBACK SHOULD NOT BE MIXED WITH ASYNC/AWAIT ONCE IT IS EXECUTED WHEN A PROMISE IS RESOLVED.

WRITABLE._FINAL(CALLBACK)#
ADDED IN: V8.0.0
CALLBACK <FUNCTION> CALL THIS FUNCTION (OPTIONALLY WITH AN ERROR ARGUMENT) WHEN FINISHED WRITING ANY REMAINING DATA.
THE _FINAL() METHOD MUST NOT BE CALLED DIRECTLY. IT MAY BE IMPLEMENTED BY CHILD CLASSES, AND IF SO, WILL BE CALLED BY THE INTERNAL WRITABLE CLASS METHODS ONLY.

THIS OPTIONAL FUNCTION WILL BE CALLED BEFORE THE STREAM CLOSES, DELAYING THE 'FINISH' EVENT UNTIL CALLBACK IS CALLED. THIS IS USEFUL TO CLOSE RESOURCES OR WRITE BUFFERED DATA BEFORE A STREAM ENDS.

ERRORS WHILE WRITING#
ERRORS OCCURRING DURING THE PROCESSING OF THE WRITABLE._WRITE(), WRITABLE._WRITEV() AND WRITABLE._FINAL() METHODS MUST BE PROPAGATED BY INVOKING THE CALLBACK AND PASSING THE ERROR AS THE FIRST ARGUMENT. THROWING AN ERROR FROM WITHIN THESE METHODS OR MANUALLY EMITTING AN 'ERROR' EVENT RESULTS IN UNDEFINED BEHAVIOR.

IF A READABLE STREAM PIPES INTO A WRITABLE STREAM WHEN WRITABLE EMITS AN ERROR, THE READABLE STREAM WILL BE UNPIPED.

CONST { WRITABLE } = REQUIRE('NODE:STREAM');

CONST MYWRITABLE = NEW WRITABLE({
  WRITE(CHUNK, ENCODING, CALLBACK) {
    IF (CHUNK.TOSTRING().INDEXOF('A') >= 0) {
      CALLBACK(NEW ERROR('CHUNK IS INVALID'));
    } ELSE {
      CALLBACK();
    }
  },
}); COPY
AN EXAMPLE WRITABLE STREAM#
THE FOLLOWING ILLUSTRATES A RATHER SIMPLISTIC (AND SOMEWHAT POINTLESS) CUSTOM WRITABLE STREAM IMPLEMENTATION. WHILE THIS SPECIFIC WRITABLE STREAM INSTANCE IS NOT OF ANY REAL PARTICULAR USEFULNESS, THE EXAMPLE ILLUSTRATES EACH OF THE REQUIRED ELEMENTS OF A CUSTOM WRITABLE STREAM INSTANCE:

CONST { WRITABLE } = REQUIRE('NODE:STREAM');

CLASS MYWRITABLE EXTENDS WRITABLE {
  _WRITE(CHUNK, ENCODING, CALLBACK) {
    IF (CHUNK.TOSTRING().INDEXOF('A') >= 0) {
      CALLBACK(NEW ERROR('CHUNK IS INVALID'));
    } ELSE {
      CALLBACK();
    }
  }
} COPY
DECODING BUFFERS IN A WRITABLE STREAM#
DECODING BUFFERS IS A COMMON TASK, FOR INSTANCE, WHEN USING TRANSFORMERS WHOSE INPUT IS A STRING. THIS IS NOT A TRIVIAL PROCESS WHEN USING MULTI-BYTE CHARACTERS ENCODING, SUCH AS UTF-8. THE FOLLOWING EXAMPLE SHOWS HOW TO DECODE MULTI-BYTE STRINGS USING STRINGDECODER AND WRITABLE.

CONST { WRITABLE } = REQUIRE('NODE:STREAM');
CONST { STRINGDECODER } = REQUIRE('NODE:STRING_DECODER');

CLASS STRINGWRITABLE EXTENDS WRITABLE {
  CONSTRUCTOR(OPTIONS) {
    SUPER(OPTIONS);
    THIS._DECODER = NEW STRINGDECODER(OPTIONS && OPTIONS.DEFAULTENCODING);
    THIS.DATA = '';
  }
  _WRITE(CHUNK, ENCODING, CALLBACK) {
    IF (ENCODING === 'BUFFER') {
      CHUNK = THIS._DECODER.WRITE(CHUNK);
    }
    THIS.DATA += CHUNK;
    CALLBACK();
  }
  _FINAL(CALLBACK) {
    THIS.DATA += THIS._DECODER.END();
    CALLBACK();
  }
}

CONST EURO = [[0XE2, 0X82], [0XAC]].MAP(BUFFER.FROM);
CONST W = NEW STRINGWRITABLE();

W.WRITE('CURRENCY: ');
W.WRITE(EURO[0]);
W.END(EURO[1]);

CONSOLE.LOG(W.DATA); // CURRENCY:  COPY
IMPLEMENTING A READABLE STREAM#
THE STREAM.READABLE CLASS IS EXTENDED TO IMPLEMENT A READABLE STREAM.

CUSTOM READABLE STREAMS MUST CALL THE NEW STREAM.READABLE([OPTIONS]) CONSTRUCTOR AND IMPLEMENT THE READABLE._READ() METHOD.

NEW STREAM.READABLE([OPTIONS])#
HISTORY
OPTIONS <OBJECT>
HIGHWATERMARK <NUMBER> THE MAXIMUM NUMBER OF BYTES TO STORE IN THE INTERNAL BUFFER BEFORE CEASING TO READ FROM THE UNDERLYING RESOURCE. DEFAULT: 16384 (16 KIB), OR 16 FOR OBJECTMODE STREAMS.
ENCODING <STRING> IF SPECIFIED, THEN BUFFERS WILL BE DECODED TO STRINGS USING THE SPECIFIED ENCODING. DEFAULT: NULL.
OBJECTMODE <BOOLEAN> WHETHER THIS STREAM SHOULD BEHAVE AS A STREAM OF OBJECTS. MEANING THAT STREAM.READ(N) RETURNS A SINGLE VALUE INSTEAD OF A BUFFER OF SIZE N. DEFAULT: FALSE.
EMITCLOSE <BOOLEAN> WHETHER OR NOT THE STREAM SHOULD EMIT 'CLOSE' AFTER IT HAS BEEN DESTROYED. DEFAULT: TRUE.
READ <FUNCTION> IMPLEMENTATION FOR THE STREAM._READ() METHOD.
DESTROY <FUNCTION> IMPLEMENTATION FOR THE STREAM._DESTROY() METHOD.
CONSTRUCT <FUNCTION> IMPLEMENTATION FOR THE STREAM._CONSTRUCT() METHOD.
AUTODESTROY <BOOLEAN> WHETHER THIS STREAM SHOULD AUTOMATICALLY CALL .DESTROY() ON ITSELF AFTER ENDING. DEFAULT: TRUE.
SIGNAL <ABORTSIGNAL> A SIGNAL REPRESENTING POSSIBLE CANCELLATION.
CONST { READABLE } = REQUIRE('NODE:STREAM');

CLASS MYREADABLE EXTENDS READABLE {
  CONSTRUCTOR(OPTIONS) {
    // CALLS THE STREAM.READABLE(OPTIONS) CONSTRUCTOR.
    SUPER(OPTIONS);
    // ...
  }
} COPY
OR, WHEN USING PRE-ES6 STYLE CONSTRUCTORS:

CONST { READABLE } = REQUIRE('NODE:STREAM');
CONST UTIL = REQUIRE('NODE:UTIL');

FUNCTION MYREADABLE(OPTIONS) {
  IF (!(THIS INSTANCEOF MYREADABLE))
    RETURN NEW MYREADABLE(OPTIONS);
  READABLE.CALL(THIS, OPTIONS);
}
UTIL.INHERITS(MYREADABLE, READABLE); COPY
OR, USING THE SIMPLIFIED CONSTRUCTOR APPROACH:

CONST { READABLE } = REQUIRE('NODE:STREAM');

CONST MYREADABLE = NEW READABLE({
  READ(SIZE) {
    // ...
  },
}); COPY
CALLING ABORT ON THE ABORTCONTROLLER CORRESPONDING TO THE PASSED ABORTSIGNAL WILL BEHAVE THE SAME WAY AS CALLING .DESTROY(NEW ABORTERROR()) ON THE READABLE CREATED.

CONST { READABLE } = REQUIRE('NODE:STREAM');
CONST CONTROLLER = NEW ABORTCONTROLLER();
CONST READ = NEW READABLE({
  READ(SIZE) {
    // ...
  },
  SIGNAL: CONTROLLER.SIGNAL,
});
// LATER, ABORT THE OPERATION CLOSING THE STREAM
CONTROLLER.ABORT(); COPY
READABLE._CONSTRUCT(CALLBACK)#
ADDED IN: V15.0.0
CALLBACK <FUNCTION> CALL THIS FUNCTION (OPTIONALLY WITH AN ERROR ARGUMENT) WHEN THE STREAM HAS FINISHED INITIALIZING.
THE _CONSTRUCT() METHOD MUST NOT BE CALLED DIRECTLY. IT MAY BE IMPLEMENTED BY CHILD CLASSES, AND IF SO, WILL BE CALLED BY THE INTERNAL READABLE CLASS METHODS ONLY.

THIS OPTIONAL FUNCTION WILL BE SCHEDULED IN THE NEXT TICK BY THE STREAM CONSTRUCTOR, DELAYING ANY _READ() AND _DESTROY() CALLS UNTIL CALLBACK IS CALLED. THIS IS USEFUL TO INITIALIZE STATE OR ASYNCHRONOUSLY INITIALIZE RESOURCES BEFORE THE STREAM CAN BE USED.

CONST { READABLE } = REQUIRE('NODE:STREAM');
CONST FS = REQUIRE('NODE:FS');

CLASS READSTREAM EXTENDS READABLE {
  CONSTRUCTOR(FILENAME) {
    SUPER();
    THIS.FILENAME = FILENAME;
    THIS.FD = NULL;
  }
  _CONSTRUCT(CALLBACK) {
    FS.OPEN(THIS.FILENAME, (ERR, FD) => {
      IF (ERR) {
        CALLBACK(ERR);
      } ELSE {
        THIS.FD = FD;
        CALLBACK();
      }
    });
  }
  _READ(N) {
    CONST BUF = BUFFER.ALLOC(N);
    FS.READ(THIS.FD, BUF, 0, N, NULL, (ERR, BYTESREAD) => {
      IF (ERR) {
        THIS.DESTROY(ERR);
      } ELSE {
        THIS.PUSH(BYTESREAD > 0 ? BUF.SLICE(0, BYTESREAD) : NULL);
      }
    });
  }
  _DESTROY(ERR, CALLBACK) {
    IF (THIS.FD) {
      FS.CLOSE(THIS.FD, (ER) => CALLBACK(ER || ERR));
    } ELSE {
      CALLBACK(ERR);
    }
  }
} COPY
READABLE._READ(SIZE)#
ADDED IN: V0.9.4
SIZE <NUMBER> NUMBER OF BYTES TO READ ASYNCHRONOUSLY
THIS FUNCTION MUST NOT BE CALLED BY APPLICATION CODE DIRECTLY. IT SHOULD BE IMPLEMENTED BY CHILD CLASSES, AND CALLED BY THE INTERNAL READABLE CLASS METHODS ONLY.

ALL READABLE STREAM IMPLEMENTATIONS MUST PROVIDE AN IMPLEMENTATION OF THE READABLE._READ() METHOD TO FETCH DATA FROM THE UNDERLYING RESOURCE.

WHEN READABLE._READ() IS CALLED, IF DATA IS AVAILABLE FROM THE RESOURCE, THE IMPLEMENTATION SHOULD BEGIN PUSHING THAT DATA INTO THE READ QUEUE USING THE THIS.PUSH(DATACHUNK) METHOD. _READ() WILL BE CALLED AGAIN AFTER EACH CALL TO THIS.PUSH(DATACHUNK) ONCE THE STREAM IS READY TO ACCEPT MORE DATA. _READ() MAY CONTINUE READING FROM THE RESOURCE AND PUSHING DATA UNTIL READABLE.PUSH() RETURNS FALSE. ONLY WHEN _READ() IS CALLED AGAIN AFTER IT HAS STOPPED SHOULD IT RESUME PUSHING ADDITIONAL DATA INTO THE QUEUE.

ONCE THE READABLE._READ() METHOD HAS BEEN CALLED, IT WILL NOT BE CALLED AGAIN UNTIL MORE DATA IS PUSHED THROUGH THE READABLE.PUSH() METHOD. EMPTY DATA SUCH AS EMPTY BUFFERS AND STRINGS WILL NOT CAUSE READABLE._READ() TO BE CALLED.

THE SIZE ARGUMENT IS ADVISORY. FOR IMPLEMENTATIONS WHERE A "READ" IS A SINGLE OPERATION THAT RETURNS DATA CAN USE THE SIZE ARGUMENT TO DETERMINE HOW MUCH DATA TO FETCH. OTHER IMPLEMENTATIONS MAY IGNORE THIS ARGUMENT AND SIMPLY PROVIDE DATA WHENEVER IT BECOMES AVAILABLE. THERE IS NO NEED TO "WAIT" UNTIL SIZE BYTES ARE AVAILABLE BEFORE CALLING STREAM.PUSH(CHUNK).

THE READABLE._READ() METHOD IS PREFIXED WITH AN UNDERSCORE BECAUSE IT IS INTERNAL TO THE CLASS THAT DEFINES IT, AND SHOULD NEVER BE CALLED DIRECTLY BY USER PROGRAMS.

READABLE._DESTROY(ERR, CALLBACK)#
ADDED IN: V8.0.0
ERR <ERROR> A POSSIBLE ERROR.
CALLBACK <FUNCTION> A CALLBACK FUNCTION THAT TAKES AN OPTIONAL ERROR ARGUMENT.
THE _DESTROY() METHOD IS CALLED BY READABLE.DESTROY(). IT CAN BE OVERRIDDEN BY CHILD CLASSES BUT IT MUST NOT BE CALLED DIRECTLY.

READABLE.PUSH(CHUNK[, ENCODING])#
HISTORY
CHUNK <BUFFER> | <UINT8ARRAY> | <STRING> | <NULL> | <ANY> CHUNK OF DATA TO PUSH INTO THE READ QUEUE. FOR STREAMS NOT OPERATING IN OBJECT MODE, CHUNK MUST BE A STRING, BUFFER OR UINT8ARRAY. FOR OBJECT MODE STREAMS, CHUNK MAY BE ANY JAVASCRIPT VALUE.
ENCODING <STRING> ENCODING OF STRING CHUNKS. MUST BE A VALID BUFFER ENCODING, SUCH AS 'UTF8' OR 'ASCII'.
RETURNS: <BOOLEAN> TRUE IF ADDITIONAL CHUNKS OF DATA MAY CONTINUE TO BE PUSHED; FALSE OTHERWISE.
WHEN CHUNK IS A BUFFER, UINT8ARRAY, OR STRING, THE CHUNK OF DATA WILL BE ADDED TO THE INTERNAL QUEUE FOR USERS OF THE STREAM TO CONSUME. PASSING CHUNK AS NULL SIGNALS THE END OF THE STREAM (EOF), AFTER WHICH NO MORE DATA CAN BE WRITTEN.

WHEN THE READABLE IS OPERATING IN PAUSED MODE, THE DATA ADDED WITH READABLE.PUSH() CAN BE READ OUT BY CALLING THE READABLE.READ() METHOD WHEN THE 'READABLE' EVENT IS EMITTED.

WHEN THE READABLE IS OPERATING IN FLOWING MODE, THE DATA ADDED WITH READABLE.PUSH() WILL BE DELIVERED BY EMITTING A 'DATA' EVENT.

THE READABLE.PUSH() METHOD IS DESIGNED TO BE AS FLEXIBLE AS POSSIBLE. FOR EXAMPLE, WHEN WRAPPING A LOWER-LEVEL SOURCE THAT PROVIDES SOME FORM OF PAUSE/RESUME MECHANISM, AND A DATA CALLBACK, THE LOW-LEVEL SOURCE CAN BE WRAPPED BY THE CUSTOM READABLE INSTANCE:

// `_SOURCE` IS AN OBJECT WITH READSTOP() AND READSTART() METHODS,
// AND AN `ONDATA` MEMBER THAT GETS CALLED WHEN IT HAS DATA, AND
// AN `ONEND` MEMBER THAT GETS CALLED WHEN THE DATA IS OVER.

CLASS SOURCEWRAPPER EXTENDS READABLE {
  CONSTRUCTOR(OPTIONS) {
    SUPER(OPTIONS);

    THIS._SOURCE = GETLOWLEVELSOURCEOBJECT();

    // EVERY TIME THERE'S DATA, PUSH IT INTO THE INTERNAL BUFFER.
    THIS._SOURCE.ONDATA = (CHUNK) => {
      // IF PUSH() RETURNS FALSE, THEN STOP READING FROM SOURCE.
      IF (!THIS.PUSH(CHUNK))
        THIS._SOURCE.READSTOP();
    };

    // WHEN THE SOURCE ENDS, PUSH THE EOF-SIGNALING `NULL` CHUNK.
    THIS._SOURCE.ONEND = () => {
      THIS.PUSH(NULL);
    };
  }
  // _READ() WILL BE CALLED WHEN THE STREAM WANTS TO PULL MORE DATA IN.
  // THE ADVISORY SIZE ARGUMENT IS IGNORED IN THIS CASE.
  _READ(SIZE) {
    THIS._SOURCE.READSTART();
  }
} COPY
THE READABLE.PUSH() METHOD IS USED TO PUSH THE CONTENT INTO THE INTERNAL BUFFER. IT CAN BE DRIVEN BY THE READABLE._READ() METHOD.

FOR STREAMS NOT OPERATING IN OBJECT MODE, IF THE CHUNK PARAMETER OF READABLE.PUSH() IS UNDEFINED, IT WILL BE TREATED AS EMPTY STRING OR BUFFER. SEE READABLE.PUSH('') FOR MORE INFORMATION.

ERRORS WHILE READING#
ERRORS OCCURRING DURING PROCESSING OF THE READABLE._READ() MUST BE PROPAGATED THROUGH THE READABLE.DESTROY(ERR) METHOD. THROWING AN ERROR FROM WITHIN READABLE._READ() OR MANUALLY EMITTING AN 'ERROR' EVENT RESULTS IN UNDEFINED BEHAVIOR.

CONST { READABLE } = REQUIRE('NODE:STREAM');

CONST MYREADABLE = NEW READABLE({
  READ(SIZE) {
    CONST ERR = CHECKSOMEERRORCONDITION();
    IF (ERR) {
      THIS.DESTROY(ERR);
    } ELSE {
      // DO SOME WORK.
    }
  },
}); COPY
AN EXAMPLE COUNTING STREAM#
THE FOLLOWING IS A BASIC EXAMPLE OF A READABLE STREAM THAT EMITS THE NUMERALS FROM 1 TO 1,000,000 IN ASCENDING ORDER, AND THEN ENDS.

CONST { READABLE } = REQUIRE('NODE:STREAM');

CLASS COUNTER EXTENDS READABLE {
  CONSTRUCTOR(OPT) {
    SUPER(OPT);
    THIS._MAX = 1000000;
    THIS._INDEX = 1;
  }

  _READ() {
    CONST I = THIS._INDEX++;
    IF (I > THIS._MAX)
      THIS.PUSH(NULL);
    ELSE {
      CONST STR = STRING(I);
      CONST BUF = BUFFER.FROM(STR, 'ASCII');
      THIS.PUSH(BUF);
    }
  }
} COPY
IMPLEMENTING A DUPLEX STREAM#
A DUPLEX STREAM IS ONE THAT IMPLEMENTS BOTH READABLE AND WRITABLE, SUCH AS A TCP SOCKET CONNECTION.

BECAUSE JAVASCRIPT DOES NOT HAVE SUPPORT FOR MULTIPLE INHERITANCE, THE STREAM.DUPLEX CLASS IS EXTENDED TO IMPLEMENT A DUPLEX STREAM (AS OPPOSED TO EXTENDING THE STREAM.READABLE AND STREAM.WRITABLE CLASSES).

THE STREAM.DUPLEX CLASS PROTOTYPICALLY INHERITS FROM STREAM.READABLE AND PARASITICALLY FROM STREAM.WRITABLE, BUT INSTANCEOF WILL WORK PROPERLY FOR BOTH BASE CLASSES DUE TO OVERRIDING SYMBOL.HASINSTANCE ON STREAM.WRITABLE.

CUSTOM DUPLEX STREAMS MUST CALL THE NEW STREAM.DUPLEX([OPTIONS]) CONSTRUCTOR AND IMPLEMENT BOTH THE READABLE._READ() AND WRITABLE._WRITE() METHODS.

NEW STREAM.DUPLEX(OPTIONS)#
HISTORY
OPTIONS <OBJECT> PASSED TO BOTH WRITABLE AND READABLE CONSTRUCTORS. ALSO HAS THE FOLLOWING FIELDS:
ALLOWHALFOPEN <BOOLEAN> IF SET TO FALSE, THEN THE STREAM WILL AUTOMATICALLY END THE WRITABLE SIDE WHEN THE READABLE SIDE ENDS. DEFAULT: TRUE.
READABLE <BOOLEAN> SETS WHETHER THE DUPLEX SHOULD BE READABLE. DEFAULT: TRUE.
WRITABLE <BOOLEAN> SETS WHETHER THE DUPLEX SHOULD BE WRITABLE. DEFAULT: TRUE.
READABLEOBJECTMODE <BOOLEAN> SETS OBJECTMODE FOR READABLE SIDE OF THE STREAM. HAS NO EFFECT IF OBJECTMODE IS TRUE. DEFAULT: FALSE.
WRITABLEOBJECTMODE <BOOLEAN> SETS OBJECTMODE FOR WRITABLE SIDE OF THE STREAM. HAS NO EFFECT IF OBJECTMODE IS TRUE. DEFAULT: FALSE.
READABLEHIGHWATERMARK <NUMBER> SETS HIGHWATERMARK FOR THE READABLE SIDE OF THE STREAM. HAS NO EFFECT IF HIGHWATERMARK IS PROVIDED.
WRITABLEHIGHWATERMARK <NUMBER> SETS HIGHWATERMARK FOR THE WRITABLE SIDE OF THE STREAM. HAS NO EFFECT IF HIGHWATERMARK IS PROVIDED.
CONST { DUPLEX } = REQUIRE('NODE:STREAM');

CLASS MYDUPLEX EXTENDS DUPLEX {
  CONSTRUCTOR(OPTIONS) {
    SUPER(OPTIONS);
    // ...
  }
} COPY
OR, WHEN USING PRE-ES6 STYLE CONSTRUCTORS:

CONST { DUPLEX } = REQUIRE('NODE:STREAM');
CONST UTIL = REQUIRE('NODE:UTIL');

FUNCTION MYDUPLEX(OPTIONS) {
  IF (!(THIS INSTANCEOF MYDUPLEX))
    RETURN NEW MYDUPLEX(OPTIONS);
  DUPLEX.CALL(THIS, OPTIONS);
}
UTIL.INHERITS(MYDUPLEX, DUPLEX); COPY
OR, USING THE SIMPLIFIED CONSTRUCTOR APPROACH:

CONST { DUPLEX } = REQUIRE('NODE:STREAM');

CONST MYDUPLEX = NEW DUPLEX({
  READ(SIZE) {
    // ...
  },
  WRITE(CHUNK, ENCODING, CALLBACK) {
    // ...
  },
}); COPY
WHEN USING PIPELINE:

CONST { TRANSFORM, PIPELINE } = REQUIRE('NODE:STREAM');
CONST FS = REQUIRE('NODE:FS');

PIPELINE(
  FS.CREATEREADSTREAM('OBJECT.JSON')
    .SETENCODING('UTF8'),
  NEW TRANSFORM({
    DECODESTRINGS: FALSE, // ACCEPT STRING INPUT RATHER THAN BUFFERS
    CONSTRUCT(CALLBACK) {
      THIS.DATA = '';
      CALLBACK();
    },
    TRANSFORM(CHUNK, ENCODING, CALLBACK) {
      THIS.DATA += CHUNK;
      CALLBACK();
    },
    FLUSH(CALLBACK) {
      TRY {
        // MAKE SURE IS VALID JSON.
        JSON.PARSE(THIS.DATA);
        THIS.PUSH(THIS.DATA);
        CALLBACK();
      } CATCH (ERR) {
        CALLBACK(ERR);
      }
    },
  }),
  FS.CREATEWRITESTREAM('VALID-OBJECT.JSON'),
  (ERR) => {
    IF (ERR) {
      CONSOLE.ERROR('FAILED', ERR);
    } ELSE {
      CONSOLE.LOG('COMPLETED');
    }
  },
); COPY
AN EXAMPLE DUPLEX STREAM#
THE FOLLOWING ILLUSTRATES A SIMPLE EXAMPLE OF A DUPLEX STREAM THAT WRAPS A HYPOTHETICAL LOWER-LEVEL SOURCE OBJECT TO WHICH DATA CAN BE WRITTEN, AND FROM WHICH DATA CAN BE READ, ALBEIT USING AN API THAT IS NOT COMPATIBLE WITH NODE.JS STREAMS. THE FOLLOWING ILLUSTRATES A SIMPLE EXAMPLE OF A DUPLEX STREAM THAT BUFFERS INCOMING WRITTEN DATA VIA THE WRITABLE INTERFACE THAT IS READ BACK OUT VIA THE READABLE INTERFACE.

CONST { DUPLEX } = REQUIRE('NODE:STREAM');
CONST KSOURCE = SYMBOL('SOURCE');

CLASS MYDUPLEX EXTENDS DUPLEX {
  CONSTRUCTOR(SOURCE, OPTIONS) {
    SUPER(OPTIONS);
    THIS[KSOURCE] = SOURCE;
  }

  _WRITE(CHUNK, ENCODING, CALLBACK) {
    // THE UNDERLYING SOURCE ONLY DEALS WITH STRINGS.
    IF (BUFFER.ISBUFFER(CHUNK))
      CHUNK = CHUNK.TOSTRING();
    THIS[KSOURCE].WRITESOMEDATA(CHUNK);
    CALLBACK();
  }

  _READ(SIZE) {
    THIS[KSOURCE].FETCHSOMEDATA(SIZE, (DATA, ENCODING) => {
      THIS.PUSH(BUFFER.FROM(DATA, ENCODING));
    });
  }
} COPY
THE MOST IMPORTANT ASPECT OF A DUPLEX STREAM IS THAT THE READABLE AND WRITABLE SIDES OPERATE INDEPENDENTLY OF ONE ANOTHER DESPITE CO-EXISTING WITHIN A SINGLE OBJECT INSTANCE.

OBJECT MODE DUPLEX STREAMS#
FOR DUPLEX STREAMS, OBJECTMODE CAN BE SET EXCLUSIVELY FOR EITHER THE READABLE OR WRITABLE SIDE USING THE READABLEOBJECTMODE AND WRITABLEOBJECTMODE OPTIONS RESPECTIVELY.

IN THE FOLLOWING EXAMPLE, FOR INSTANCE, A NEW TRANSFORM STREAM (WHICH IS A TYPE OF DUPLEX STREAM) IS CREATED THAT HAS AN OBJECT MODE WRITABLE SIDE THAT ACCEPTS JAVASCRIPT NUMBERS THAT ARE CONVERTED TO HEXADECIMAL STRINGS ON THE READABLE SIDE.

CONST { TRANSFORM } = REQUIRE('NODE:STREAM');

// ALL TRANSFORM STREAMS ARE ALSO DUPLEX STREAMS.
CONST MYTRANSFORM = NEW TRANSFORM({
  WRITABLEOBJECTMODE: TRUE,

  TRANSFORM(CHUNK, ENCODING, CALLBACK) {
    // COERCE THE CHUNK TO A NUMBER IF NECESSARY.
    CHUNK |= 0;

    // TRANSFORM THE CHUNK INTO SOMETHING ELSE.
    CONST DATA = CHUNK.TOSTRING(16);

    // PUSH THE DATA ONTO THE READABLE QUEUE.
    CALLBACK(NULL, '0'.REPEAT(DATA.LENGTH % 2) + DATA);
  },
});

MYTRANSFORM.SETENCODING('ASCII');
MYTRANSFORM.ON('DATA', (CHUNK) => CONSOLE.LOG(CHUNK));

MYTRANSFORM.WRITE(1);
// PRINTS: 01
MYTRANSFORM.WRITE(10);
// PRINTS: 0A
MYTRANSFORM.WRITE(100);
// PRINTS: 64 COPY
IMPLEMENTING A TRANSFORM STREAM#
A TRANSFORM STREAM IS A DUPLEX STREAM WHERE THE OUTPUT IS COMPUTED IN SOME WAY FROM THE INPUT. EXAMPLES INCLUDE ZLIB STREAMS OR CRYPTO STREAMS THAT COMPRESS, ENCRYPT, OR DECRYPT DATA.

THERE IS NO REQUIREMENT THAT THE OUTPUT BE THE SAME SIZE AS THE INPUT, THE SAME NUMBER OF CHUNKS, OR ARRIVE AT THE SAME TIME. FOR EXAMPLE, A HASH STREAM WILL ONLY EVER HAVE A SINGLE CHUNK OF OUTPUT WHICH IS PROVIDED WHEN THE INPUT IS ENDED. A ZLIB STREAM WILL PRODUCE OUTPUT THAT IS EITHER MUCH SMALLER OR MUCH LARGER THAN ITS INPUT.

THE STREAM.TRANSFORM CLASS IS EXTENDED TO IMPLEMENT A TRANSFORM STREAM.

THE STREAM.TRANSFORM CLASS PROTOTYPICALLY INHERITS FROM STREAM.DUPLEX AND IMPLEMENTS ITS OWN VERSIONS OF THE WRITABLE._WRITE() AND READABLE._READ() METHODS. CUSTOM TRANSFORM IMPLEMENTATIONS MUST IMPLEMENT THE TRANSFORM._TRANSFORM() METHOD AND MAY ALSO IMPLEMENT THE TRANSFORM._FLUSH() METHOD.

CARE MUST BE TAKEN WHEN USING TRANSFORM STREAMS IN THAT DATA WRITTEN TO THE STREAM CAN CAUSE THE WRITABLE SIDE OF THE STREAM TO BECOME PAUSED IF THE OUTPUT ON THE READABLE SIDE IS NOT CONSUMED.

NEW STREAM.TRANSFORM([OPTIONS])#
OPTIONS <OBJECT> PASSED TO BOTH WRITABLE AND READABLE CONSTRUCTORS. ALSO HAS THE FOLLOWING FIELDS:
TRANSFORM <FUNCTION> IMPLEMENTATION FOR THE STREAM._TRANSFORM() METHOD.
FLUSH <FUNCTION> IMPLEMENTATION FOR THE STREAM._FLUSH() METHOD.
CONST { TRANSFORM } = REQUIRE('NODE:STREAM');

CLASS MYTRANSFORM EXTENDS TRANSFORM {
  CONSTRUCTOR(OPTIONS) {
    SUPER(OPTIONS);
    // ...
  }
} COPY
OR, WHEN USING PRE-ES6 STYLE CONSTRUCTORS:

CONST { TRANSFORM } = REQUIRE('NODE:STREAM');
CONST UTIL = REQUIRE('NODE:UTIL');

FUNCTION MYTRANSFORM(OPTIONS) {
  IF (!(THIS INSTANCEOF MYTRANSFORM))
    RETURN NEW MYTRANSFORM(OPTIONS);
  TRANSFORM.CALL(THIS, OPTIONS);
}
UTIL.INHERITS(MYTRANSFORM, TRANSFORM); COPY
OR, USING THE SIMPLIFIED CONSTRUCTOR APPROACH:

CONST { TRANSFORM } = REQUIRE('NODE:STREAM');

CONST MYTRANSFORM = NEW TRANSFORM({
  TRANSFORM(CHUNK, ENCODING, CALLBACK) {
    // ...
  },
}); COPY
EVENT: 'END'#
THE 'END' EVENT IS FROM THE STREAM.READABLE CLASS. THE 'END' EVENT IS EMITTED AFTER ALL DATA HAS BEEN OUTPUT, WHICH OCCURS AFTER THE CALLBACK IN TRANSFORM._FLUSH() HAS BEEN CALLED. IN THE CASE OF AN ERROR, 'END' SHOULD NOT BE EMITTED.

EVENT: 'FINISH'#
THE 'FINISH' EVENT IS FROM THE STREAM.WRITABLE CLASS. THE 'FINISH' EVENT IS EMITTED AFTER STREAM.END() IS CALLED AND ALL CHUNKS HAVE BEEN PROCESSED BY STREAM._TRANSFORM(). IN THE CASE OF AN ERROR, 'FINISH' SHOULD NOT BE EMITTED.

TRANSFORM._FLUSH(CALLBACK)#
CALLBACK <FUNCTION> A CALLBACK FUNCTION (OPTIONALLY WITH AN ERROR ARGUMENT AND DATA) TO BE CALLED WHEN REMAINING DATA HAS BEEN FLUSHED.
THIS FUNCTION MUST NOT BE CALLED BY APPLICATION CODE DIRECTLY. IT SHOULD BE IMPLEMENTED BY CHILD CLASSES, AND CALLED BY THE INTERNAL READABLE CLASS METHODS ONLY.

IN SOME CASES, A TRANSFORM OPERATION MAY NEED TO EMIT AN ADDITIONAL BIT OF DATA AT THE END OF THE STREAM. FOR EXAMPLE, A ZLIB COMPRESSION STREAM WILL STORE AN AMOUNT OF INTERNAL STATE USED TO OPTIMALLY COMPRESS THE OUTPUT. WHEN THE STREAM ENDS, HOWEVER, THAT ADDITIONAL DATA NEEDS TO BE FLUSHED SO THAT THE COMPRESSED DATA WILL BE COMPLETE.

CUSTOM TRANSFORM IMPLEMENTATIONS MAY IMPLEMENT THE TRANSFORM._FLUSH() METHOD. THIS WILL BE CALLED WHEN THERE IS NO MORE WRITTEN DATA TO BE CONSUMED, BUT BEFORE THE 'END' EVENT IS EMITTED SIGNALING THE END OF THE READABLE STREAM.

WITHIN THE TRANSFORM._FLUSH() IMPLEMENTATION, THE TRANSFORM.PUSH() METHOD MAY BE CALLED ZERO OR MORE TIMES, AS APPROPRIATE. THE CALLBACK FUNCTION MUST BE CALLED WHEN THE FLUSH OPERATION IS COMPLETE.

THE TRANSFORM._FLUSH() METHOD IS PREFIXED WITH AN UNDERSCORE BECAUSE IT IS INTERNAL TO THE CLASS THAT DEFINES IT, AND SHOULD NEVER BE CALLED DIRECTLY BY USER PROGRAMS.

TRANSFORM._TRANSFORM(CHUNK, ENCODING, CALLBACK)#
CHUNK <BUFFER> | <STRING> | <ANY> THE BUFFER TO BE TRANSFORMED, CONVERTED FROM THE STRING PASSED TO STREAM.WRITE(). IF THE STREAM'S DECODESTRINGS OPTION IS FALSE OR THE STREAM IS OPERATING IN OBJECT MODE, THE CHUNK WILL NOT BE CONVERTED & WILL BE WHATEVER WAS PASSED TO STREAM.WRITE().
ENCODING <STRING> IF THE CHUNK IS A STRING, THEN THIS IS THE ENCODING TYPE. IF CHUNK IS A BUFFER, THEN THIS IS THE SPECIAL VALUE 'BUFFER'. IGNORE IT IN THAT CASE.
CALLBACK <FUNCTION> A CALLBACK FUNCTION (OPTIONALLY WITH AN ERROR ARGUMENT AND DATA) TO BE CALLED AFTER THE SUPPLIED CHUNK HAS BEEN PROCESSED.
THIS FUNCTION MUST NOT BE CALLED BY APPLICATION CODE DIRECTLY. IT SHOULD BE IMPLEMENTED BY CHILD CLASSES, AND CALLED BY THE INTERNAL READABLE CLASS METHODS ONLY.

ALL TRANSFORM STREAM IMPLEMENTATIONS MUST PROVIDE A _TRANSFORM() METHOD TO ACCEPT INPUT AND PRODUCE OUTPUT. THE TRANSFORM._TRANSFORM() IMPLEMENTATION HANDLES THE BYTES BEING WRITTEN, COMPUTES AN OUTPUT, THEN PASSES THAT OUTPUT OFF TO THE READABLE PORTION USING THE TRANSFORM.PUSH() METHOD.

THE TRANSFORM.PUSH() METHOD MAY BE CALLED ZERO OR MORE TIMES TO GENERATE OUTPUT FROM A SINGLE INPUT CHUNK, DEPENDING ON HOW MUCH IS TO BE OUTPUT AS A RESULT OF THE CHUNK.

IT IS POSSIBLE THAT NO OUTPUT IS GENERATED FROM ANY GIVEN CHUNK OF INPUT DATA.

THE CALLBACK FUNCTION MUST BE CALLED ONLY WHEN THE CURRENT CHUNK IS COMPLETELY CONSUMED. THE FIRST ARGUMENT PASSED TO THE CALLBACK MUST BE AN ERROR OBJECT IF AN ERROR OCCURRED WHILE PROCESSING THE INPUT OR NULL OTHERWISE. IF A SECOND ARGUMENT IS PASSED TO THE CALLBACK, IT WILL BE FORWARDED ON TO THE TRANSFORM.PUSH() METHOD. IN OTHER WORDS, THE FOLLOWING ARE EQUIVALENT:

TRANSFORM.PROTOTYPE._TRANSFORM = FUNCTION(DATA, ENCODING, CALLBACK) {
  THIS.PUSH(DATA);
  CALLBACK();
};

TRANSFORM.PROTOTYPE._TRANSFORM = FUNCTION(DATA, ENCODING, CALLBACK) {
  CALLBACK(NULL, DATA);
}; COPY
THE TRANSFORM._TRANSFORM() METHOD IS PREFIXED WITH AN UNDERSCORE BECAUSE IT IS INTERNAL TO THE CLASS THAT DEFINES IT, AND SHOULD NEVER BE CALLED DIRECTLY BY USER PROGRAMS.

TRANSFORM._TRANSFORM() IS NEVER CALLED IN PARALLEL; STREAMS IMPLEMENT A QUEUE MECHANISM, AND TO RECEIVE THE NEXT CHUNK, CALLBACK MUST BE CALLED, EITHER SYNCHRONOUSLY OR ASYNCHRONOUSLY.

CLASS: STREAM.PASSTHROUGH#
THE STREAM.PASSTHROUGH CLASS IS A TRIVIAL IMPLEMENTATION OF A TRANSFORM STREAM THAT SIMPLY PASSES THE INPUT BYTES ACROSS TO THE OUTPUT. ITS PURPOSE IS PRIMARILY FOR EXAMPLES AND TESTING, BUT THERE ARE SOME USE CASES WHERE STREAM.PASSTHROUGH IS USEFUL AS A BUILDING BLOCK FOR NOVEL SORTS OF STREAMS.

ADDITIONAL NOTES#
STREAMS COMPATIBILITY WITH ASYNC GENERATORS AND ASYNC ITERATORS#
WITH THE SUPPORT OF ASYNC GENERATORS AND ITERATORS IN JAVASCRIPT, ASYNC GENERATORS ARE EFFECTIVELY A FIRST-CLASS LANGUAGE-LEVEL STREAM CONSTRUCT AT THIS POINT.

SOME COMMON INTEROP CASES OF USING NODE.JS STREAMS WITH ASYNC GENERATORS AND ASYNC ITERATORS ARE PROVIDED BELOW.

CONSUMING READABLE STREAMS WITH ASYNC ITERATORS#
(ASYNC FUNCTION() {
  FOR AWAIT (CONST CHUNK OF READABLE) {
    CONSOLE.LOG(CHUNK);
  }
})(); COPY
ASYNC ITERATORS REGISTER A PERMANENT ERROR HANDLER ON THE STREAM TO PREVENT ANY UNHANDLED POST-DESTROY ERRORS.

CREATING READABLE STREAMS WITH ASYNC GENERATORS#
A NODE.JS READABLE STREAM CAN BE CREATED FROM AN ASYNCHRONOUS GENERATOR USING THE READABLE.FROM() UTILITY METHOD:

CONST { READABLE } = REQUIRE('NODE:STREAM');

CONST AC = NEW ABORTCONTROLLER();
CONST SIGNAL = AC.SIGNAL;

ASYNC FUNCTION * GENERATE() {
  YIELD 'A';
  AWAIT SOMELONGRUNNINGFN({ SIGNAL });
  YIELD 'B';
  YIELD 'C';
}

CONST READABLE = READABLE.FROM(GENERATE());
READABLE.ON('CLOSE', () => {
  AC.ABORT();
});

READABLE.ON('DATA', (CHUNK) => {
  CONSOLE.LOG(CHUNK);
}); COPY
PIPING TO WRITABLE STREAMS FROM ASYNC ITERATORS#
WHEN WRITING TO A WRITABLE STREAM FROM AN ASYNC ITERATOR, ENSURE CORRECT HANDLING OF BACKPRESSURE AND ERRORS. STREAM.PIPELINE() ABSTRACTS AWAY THE HANDLING OF BACKPRESSURE AND BACKPRESSURE-RELATED ERRORS:

CONST FS = REQUIRE('NODE:FS');
CONST { PIPELINE } = REQUIRE('NODE:STREAM');
CONST { PIPELINE: PIPELINEPROMISE } = REQUIRE('NODE:STREAM/PROMISES');

CONST WRITABLE = FS.CREATEWRITESTREAM('./FILE');

CONST AC = NEW ABORTCONTROLLER();
CONST SIGNAL = AC.SIGNAL;

CONST ITERATOR = CREATEITERATOR({ SIGNAL });

// CALLBACK PATTERN
PIPELINE(ITERATOR, WRITABLE, (ERR, VALUE) => {
  IF (ERR) {
    CONSOLE.ERROR(ERR);
  } ELSE {
    CONSOLE.LOG(VALUE, 'VALUE RETURNED');
  }
}).ON('CLOSE', () => {
  AC.ABORT();
});

// PROMISE PATTERN
PIPELINEPROMISE(ITERATOR, WRITABLE)
  .THEN((VALUE) => {
    CONSOLE.LOG(VALUE, 'VALUE RETURNED');
  })
  .CATCH((ERR) => {
    CONSOLE.ERROR(ERR);
    AC.ABORT();
  }); COPY
COMPATIBILITY WITH OLDER NODE.JS VERSIONS#
PRIOR TO NODE.JS 0.10, THE READABLE STREAM INTERFACE WAS SIMPLER, BUT ALSO LESS POWERFUL AND LESS USEFUL.

RATHER THAN WAITING FOR CALLS TO THE STREAM.READ() METHOD, 'DATA' EVENTS WOULD BEGIN EMITTING IMMEDIATELY. APPLICATIONS THAT WOULD NEED TO PERFORM SOME AMOUNT OF WORK TO DECIDE HOW TO HANDLE DATA WERE REQUIRED TO STORE READ DATA INTO BUFFERS SO THE DATA WOULD NOT BE LOST.
THE STREAM.PAUSE() METHOD WAS ADVISORY, RATHER THAN GUARANTEED. THIS MEANT THAT IT WAS STILL NECESSARY TO BE PREPARED TO RECEIVE 'DATA' EVENTS EVEN WHEN THE STREAM WAS IN A PAUSED STATE.
IN NODE.JS 0.10, THE READABLE CLASS WAS ADDED. FOR BACKWARD COMPATIBILITY WITH OLDER NODE.JS PROGRAMS, READABLE STREAMS SWITCH INTO "FLOWING MODE" WHEN A 'DATA' EVENT HANDLER IS ADDED, OR WHEN THE STREAM.RESUME() METHOD IS CALLED. THE EFFECT IS THAT, EVEN WHEN NOT USING THE NEW STREAM.READ() METHOD AND 'READABLE' EVENT, IT IS NO LONGER NECESSARY TO WORRY ABOUT LOSING 'DATA' CHUNKS.

WHILE MOST APPLICATIONS WILL CONTINUE TO FUNCTION NORMALLY, THIS INTRODUCES AN EDGE CASE IN THE FOLLOWING CONDITIONS:

NO 'DATA' EVENT LISTENER IS ADDED.
THE STREAM.RESUME() METHOD IS NEVER CALLED.
THE STREAM IS NOT PIPED TO ANY WRITABLE DESTINATION.
FOR EXAMPLE, CONSIDER THE FOLLOWING CODE:

// WARNING!  BROKEN!
NET.CREATESERVER((SOCKET) => {

  // WE ADD AN 'END' LISTENER, BUT NEVER CONSUME THE DATA.
  SOCKET.ON('END', () => {
    // IT WILL NEVER GET HERE.
    SOCKET.END('THE MESSAGE WAS RECEIVED BUT WAS NOT PROCESSED.\N');
  });

}).LISTEN(1337); COPY
PRIOR TO NODE.JS 0.10, THE INCOMING MESSAGE DATA WOULD BE SIMPLY DISCARDED. HOWEVER, IN NODE.JS 0.10 AND BEYOND, THE SOCKET REMAINS PAUSED FOREVER.

THE WORKAROUND IN THIS SITUATION IS TO CALL THE STREAM.RESUME() METHOD TO BEGIN THE FLOW OF DATA:

// WORKAROUND.
NET.CREATESERVER((SOCKET) => {
  SOCKET.ON('END', () => {
    SOCKET.END('THE MESSAGE WAS RECEIVED BUT WAS NOT PROCESSED.\N');
  });

  // START THE FLOW OF DATA, DISCARDING IT.
  SOCKET.RESUME();
}).LISTEN(1337); COPY
IN ADDITION TO NEW READABLE STREAMS SWITCHING INTO FLOWING MODE, PRE-0.10 STYLE STREAMS CAN BE WRAPPED IN A READABLE CLASS USING THE READABLE.WRAP() METHOD.

READABLE.READ(0)#
THERE ARE SOME CASES WHERE IT IS NECESSARY TO TRIGGER A REFRESH OF THE UNDERLYING READABLE STREAM MECHANISMS, WITHOUT ACTUALLY CONSUMING ANY DATA. IN SUCH CASES, IT IS POSSIBLE TO CALL READABLE.READ(0), WHICH WILL ALWAYS RETURN NULL.

IF THE INTERNAL READ BUFFER IS BELOW THE HIGHWATERMARK, AND THE STREAM IS NOT CURRENTLY READING, THEN CALLING STREAM.READ(0) WILL TRIGGER A LOW-LEVEL STREAM._READ() CALL.

WHILE MOST APPLICATIONS WILL ALMOST NEVER NEED TO DO THIS, THERE ARE SITUATIONS WITHIN NODE.JS WHERE THIS IS DONE, PARTICULARLY IN THE READABLE STREAM CLASS INTERNALS.

READABLE.PUSH('')#
USE OF READABLE.PUSH('') IS NOT RECOMMENDED.

PUSHING A ZERO-BYTE STRING, BUFFER, OR UINT8ARRAY TO A STREAM THAT IS NOT IN OBJECT MODE HAS AN INTERESTING SIDE EFFECT. BECAUSE IT IS A CALL TO READABLE.PUSH(), THE CALL WILL END THE READING PROCESS. HOWEVER, BECAUSE THE ARGUMENT IS AN EMPTY STRING, NO DATA IS ADDED TO THE READABLE BUFFER SO THERE IS NOTHING FOR A USER TO CONSUME.

HIGHWATERMARK DISCREPANCY AFTER CALLING READABLE.SETENCODING()#
THE USE OF READABLE.SETENCODING() WILL CHANGE THE BEHAVIOR OF HOW THE HIGHWATERMARK OPERATES IN NON-OBJECT MODE.

TYPICALLY, THE SIZE OF THE CURRENT BUFFER IS MEASURED AGAINST THE HIGHWATERMARK IN BYTES. HOWEVER, AFTER SETENCODING() IS CALLED, THE COMPARISON FUNCTION WILL BEGIN TO MEASURE THE BUFFER'S SIZE IN CHARACTERS.

THIS IS NOT A PROBLEM IN COMMON CASES WITH LATIN1 OR ASCII. BUT IT IS ADVISED TO BE MINDFUL ABOUT THIS BEHAVIOR WHEN WORKING WITH STRINGS THAT COULD CONTAIN MULTI-BYTE CHARACTERS.